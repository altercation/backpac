#!/bin/bash

Debug () { echo -e ">>> DEBUG: EXECUTING ${FUNCNAME[1]} AT LINE ${BASH_LINENO[0]}${*:+ >>> }${*:-}"; }
Is_True () { case $(Lower_Case ${1:-}) in true|yes|1|y) return 0 ;; *) return 1 ;; esac; }
Is_False () { case $(Lower_Case ${1:-}) in false|no|0|n) return 0 ;; *) return 1 ;; esac; }
Is_Array () { [[ -n ${1:-} ]] && declare | egrep -q "^${1}=\(" || return 1; }
Upper_Case () { echo -n "$*" | tr '[:lower:]' '[:upper:]'; }
Lower_Case () { echo -n "$*" | tr '[:upper:]' '[:lower:]'; }

Fail_Critically () { echo -e "\nCRITICAL FAILURE. Reported by ${FUNCNAME[1]}:\n$(echo ${1})"; exit 1; }
Fail_Noncritically () { echo -e "\nNONCRITICAL FAILURE. Reported by ${FUNCNAME[1]}:\n$(echo ${1})"; }

regen () { echo "TODO: add mkinitcpio, grub regen here"; }
Install_Package () { sudo pacman -Sq --noconfirm "${1}"; }
Uninstall_Package () { sudo pacman -Rsu --noconfirm "${1}"; }

# Read a file's contents, stripping comment lines
Read_File_Drop_Comments () { [[ -e ${1} ]] && cat $1 | egrep "^\s*[^#]" || Unit_Report "FILE NOT PRESENT: ${1}"; } #return 0

UI_Passive_Alert () { eval "local _alert=\"${1:-}\""; [[ -n ${_alert:-} ]] && echo -e "${_alert}"; }
UI_Incremental_Alert () { [[ -n ${1:-} ]] && echo -ne "${1}" || echo; }
UI_Passive_Warning () { echo -e "\nWARNING"; eval "echo -e \"${*}\""; }
UI_Query_Warning () { echo -e "\nWARNING"; eval "echo -e \"${*}\""; Query "Proceed?"; }

# takes two arguments
# 1: Prompt string to which is added (y/n)
# 2: name of temporary global to set to true if response is for all
Query ()
{
    eval "local _alert=\"${1}\""
    echo -en "${_alert}"
    while true
    do
        [[ -n ${2:-} ]] \
            && local _prompt=" (y/n for this; Y/N for all remaining) " \
            || local _prompt=" (y/n) "
        read -p "${_prompt}" response
        case $response in
            y*) return 0 ;;
            Y*) [[ -n ${2:-} ]] && eval ${2}=true; return 0 ;;
            n*) return 1 ;;
            N*) [[ -n ${2:-} ]] && eval ${2}=true; return 1 ;;
        esac
    done
}

Unit_Report ()
{
    # find parent UNIT_ function
    _message="$(echo $*)"
    local _category
    for _category in "${FUNCNAME[@]}"
    do
        [[ $(expr "${_category}" : "UNIT_") > 0 ]] && break
    done

    # add to list of categories if this is a new REPORT_ value
    if [[ -z ${REPORT_[${_category#UNIT_}]:-} ]]
    then
        REPORT_SEQUENCE_[$((${#REPORT_SEQUENCE_[@]}+1))]=${_category#UNIT_}
    fi

    # add report string to report category string
    #REPORT_[${_category#UNIT_}]+="$(echo ${_message} | fmt -uw ${COLUMNS:-72} )\n";
    REPORT_[${_category#UNIT_}]+="$(echo ${_message})\n";
}

# Install_Package_From_AUR <package_name>
# Syncs dependencies from official repositories with makepkg
Install_Package_From_AUR ()
{
    package_name="${1}"
    build_path="${TMPDIR}/build"
    revert_path="${PWD}"
    source_path="https://aur.archlinux.org/packages/${package_name}/${package_name}.tar.gz"

    pacman -Qs ^${package_name}$ &>/dev/null && return 0 # already installed

    _Prepare ()
    {
        rm -rf "${build_path}" || true
        mkdir -p "${build_path}"
    }

    _Make_And_Install ()
    {
        cd "${build_path}"
        wget "${source_path}"
        tar -xzvf "${package_name}.tar.gz"
        cd "${package_name}"
        makepkg -si --noconfirm
    }

    _Cleanup ()
    {
        cd ${revert_path}
        rm -rf ${build_path} || true
        unset source_path
        unset revert_path
        unset build_path
        unset package_name
    }

    Execute_With_Failsafe_Cleanup _Prepare _Make_And_Install _Cleanup
}

# Execute_With_Failsafe_Cleanup "risky" "commands" "mandatory cleanup"
# when executing a risky command with a mandatory cleanup action, this sets up 
# the trap, runs the risky commands and executes cleanup, finally breaking down 
# the trap and restoring the previous trap state.
Execute_With_Failsafe_Cleanup ()
{
    local _previous_traps=$(trap)
    eval local _rollback_command=\"\${${#@}}\"
    eval trap \'${_rollback_command} && return 1\' INT TERM EXIT

    local _command=
    for _command in $(seq ${#@})
    do
        eval "${!_command}"
    done

    #trap - INT TERM EXIT
    eval "${_previous_traps}"
}

# Execute_With_Failsafe_Rollback "risky" "commands "conditional rollback"
# when executing a risky command with a rollback action only required upon 
# critical failure, this sets up the trap and runs the risky commands, finally 
# breaking down the trap and restoring the previous trap state. The rollback 
# command is only executed upon critical failure.
Execute_With_Failsafe_Rollback ()
{
    local _previous_traps=$(trap)
    eval local _rollback_command=\"\${${#@}}\"
    eval trap \'${_rollback_command} && return 1\' INT TERM EXIT

    local _command=
    local _num_args_less_one=$((${#@}-1))
    for _command in $(seq ${_num_args_less_one})
    do
        eval "${!_command}"
    done

    trap - INT TERM EXIT
    eval "${_previous_traps}"
}

Options_Initialize ()
{
# use original command line options from main
set -- $CMDLINE_OPTIONS

# used throughout this funcion; make sure it's local
local _option_array

# read flags into a new array for reverse option lookup using getopts
local _option_flags="h" # we always want 'h' for 'help'
for _option_array in ${!OPT_*}
do
    eval local _flag=\${${_option_array}[FLAG]}
    local _option_flags+="$_flag"       # retain colon if present
    FLAG_[${_flag%:}]="$_option_array"  # strip colon if present
done

# use getopts to process command line options and set values here
local _option_flag
while getopts "${_option_flags}" _option_flag
do case ${_option_flag} in
    \?) exit 1 ;; # getopts has detected an incorrectly formatted option
    h)  Usage; exit 0 ;;
    *)  local _option=${FLAG_[${_option_flag}]}
        local _item;
        eval ${_option}[ALERT]=\"\${${_option}[ALERT_SET]}\"
        eval ${_option}[SET]="true"
        [[ -n ${OPTARG:-} ]] \
        && eval ${_option}[STATE]=\"\${OPTARG}\" \
        || eval ${_option}[STATE]=\"\${${_option}[STATE_SET]}\"
    ;;
esac done

# set GLOBAL_OPTION from equivalent OPT_GLOBAL_OPTION_
for _option_array in ${!OPT_*}
do
    local _global_option=${_option_array#OPT_}
    eval ${_global_option%_}=\"\${$_option_array[STATE]}\"
done

# check for any conflicts
for _option_array in ${!OPT_*}
do
    eval local _test_option_is_set=\"\${$_option_array[SET]:-}\"
    if [[ -n ${_test_option_is_set} ]]
    then
        eval local _conflict_name=\"\${$_option_array[CONFLICTS]:-}\"
        [[ -z ${_conflict_name} ]] && _conflict_value=false \
        || eval local _conflict_value=\"\${$_conflict_name}\"
        if Is_True ${_conflict_value}
        then
            eval local _warning=\"Cannot use -\${OPT_${_conflict_name}_[FLAG]} \
            and -\${$_option_array[FLAG]} command line options simultaneously.\"
            UI_Passive_Warning "$(echo ${_warning})\n"
            exit 0
        fi
    fi
done
}

Options_Summary ()
{
# prepare option summary dialog string
local _option_array
for _option_array in ${!OPT_*}
do
    local _p="()"
    eval [[ -n \${$_option_array[SET]:-} ]] && _p="  "
    eval echo \"${_p:0:1}-\${$_option_array[FLAG]%:}${_p:1:1}\\t\${$_option_array[ALERT]:-}\"
done
}

Options_Warning ()
{
# identify any warnings and prepare a warning dialog string
local _option_array
for _option_array in ${!OPT_*}
do
    eval local _test_set=\"\${$_option_array[SET]:-}\"
    if [[ -n ${_test_set} ]]
    then
        eval local _warn_condition=\"\${!$_option_array[WARN_CONDITION]:-false}\"
        if Is_True $_warn_condition
        then
            eval echo \"\${$_option_array[WARNING]:-}\"
        fi
    fi
done
}

Usage ()
{
    UI_Passive_Alert "\n${SCRIPTNAME:-0} options summary:\n"
    local _option_array
    for _option_array in ${!OPT_*}
    do
        local _p="  "
        eval echo -e \"${_p:0:1}-\${$_option_array[FLAG]%:}${_p:1:1}\\t\${$_option_array[USAGE]:-}\"
    done
    UI_Passive_Alert "\n${SCRIPTNAME:-0} current configuration:"
    UI_Passive_Alert "${USAGE_SYSTEM_CONFIG:-}"
    UI_Passive_Alert "\n${SCRIPTNAME:-0} usage:"
    UI_Passive_Alert "${USAGE_SUMMARY}"
}

_Set_Op_Precheck ()
{
    if Is_Array ${1:-} && Is_Array ${2:-} && [[ -n ${3:-} ]]
    then
        return 0
    else
        Fail_Critically "${FUNCNAME[1]} requires the names of two existing 
        array variables followed by the name of a new variable which will be 
        used as a result array."
    fi
}

Set_Op_Union ()
{
    local _set_a="${1}"
    local _set_b="${2}"
    # should be using clean data, but we shouldn't trust in that
    _set_a="$(echo ${_set_a} | Normalize_To_List)"
    _set_b="$(echo ${_set_b} | Normalize_To_List)"
    echo $_set_a $_set_b | Normalize_To_List
}
Set_Op_Intersection ()
{
    local _set_a="${1}"
    local _set_b="${2}"
    # should be using clean data, but we shouldn't trust in that
    _set_a="$(echo ${_set_a} | Normalize_To_List)"
    _set_b="$(echo ${_set_b} | Normalize_To_List)"
    echo "$(comm -12 <(echo "${_set_a}") <(echo "${_set_b}"))"
}
Set_Op_Difference ()
{
    local _set_a="${1}"
    local _set_b="${2}"
    # should be using clean data, but we shouldn't trust in that
    _set_a="$(echo ${_set_a} | Normalize_To_List)"
    _set_b="$(echo ${_set_b} | Normalize_To_List)"
    echo "$(comm -23 <(echo "${_set_a}") <(echo "${_set_b}"))"
}

# Given a potentially dirty input value, clean it up and output as 
# a one-item-per-line list (assumes items are separated by spaces)
#Normalize_List ()
#{
#    local _input _line
#    if [[ -n ${1:-} ]]
#    then
#        _input="${1}"
#    else
#        while read _line
#        do
#            _input+="${_line} "
#        done
#    fi
#    echo ${_input} | tr -s " " "\n" | sort -u
#}

# Data_To_Sorted_Array input_var_name output_var_name
# Can take either: two input values (both variable *names*), input/ouput
# or piped input and single output array variable name
# --
# If input data is given as variable name, variable can be array or list
# and list can be newline or space separated items
Normalize_To_Array ()
{
    if [[ -n ${2:-} ]]
    then
        _array_name=${2:-}
        Is_Array ${1:-} && eval _data_content+="\${$1[*]}" || _data_content="${!1}"
        eval ${_array_name}=\(\)
        _IFS="$IFS"; IFS="\n"
        local _item
        for _item in $(echo ${_data_content} | tr -s " " "\n" | sort -u)
        do eval ${_array_name}+=\(\"\${_item} \"\); done
        IFS="$_IFS"
    else
        while read _line
        do _data_content+="${_line} "; done
        [[ -z ${_data_content} ]] && Fail_Critically "No input received."
        _IFS="$IFS"; IFS="\n"
        local _item
        for _item in $(echo ${_data_content} | tr -s " " "\n" | sort -u)
        do echo "${_item}"; done
        IFS="$_IFS"
    fi
}

Normalize_To_List ()
{
    # normalize input (command line or piped) to single line space delimited 
    [[ -n ${1:-} ]] && _input="$(echo ${1})" \
        || while read _line; do _input+="${_line} "; done
    [[ -n ${_input:-} ]] && ( echo ${_input} | tr -s " " "\n" | sort -u ) \
        || return 0
}


Ask_Auto_Action ()
{
# ASK_AUTO_SOURCE_=(
# [LIST_NAME]='testlist'
# [LIST_VALUE]='if no global list used via LIST_NAME, this can contain actual list source'
# [QUERY_STRING]='string for query prompt ${_item}'
# [FORCE_VALUE]='${FORCE}'
# [DEFAULT_CHOICE]='false'
#
# [ACTION_CMD]='echo "command if selected y/Y"'
#
# [EXECUTED_CMD]='echo "executed items include: $_executed"'
# [SKIPPED_CMD]='echo "skipped items include: $_skipped_list"'
# [FAILED_CMD]='echo "failed items include: $_failed_list"'
#
# [SKIPPED_RTN_NAME]='name_of_var_to_return_skipped_list'
# [EXECUTED_RTN_NAME]='name_of_var_to_return_skipped_list'
# [FAILED_RTN_NAME]='name_of_var_to_return_skipped_list'
#
# )
# Ask_Auto_Action ASK_AUTO_SET_NAME_
local _source_set="${1}"

local _item=
local _executed_list=
local _failed_list=
local _skipped_list=

eval "local _list_var_name=\"\${$_source_set[LIST_VAR_NAME]:-}\""
if [[ -n ${_list_var_name:-} ]]
then
    eval "local _list=\"\$(echo \${!_list_var_name} | Normalize_List)\""
else
    eval "local _list=\"\$(echo \${$_source_set[LIST_VALUE]} | Normalize_List)\""
fi
eval "local _query_string=\"\${$_source_set[QUERY_STRING]}\""
eval "local _force=\"\${$_source_set[FORCE_VALUE]}\""
eval "local _default_choice=\"\${$_source_set[DEFAULT_CHOICE]}\""
_action_command   () { eval eval \${$_source_set[ACTION_CMD]}; }
_executed_command () { eval eval \${$_source_set[EXECUTED_CMD]}; }
_skipped_command  () { eval eval \${$_source_set[SKIPPED_CMD]}; }
_failed_command   () { eval eval \${$_source_set[FAILED_CMD]}; }
_executed_list_command () { eval eval \${$_source_set[EXECUTED_LIST_CMD]}; }
_skipped_list_command  () { eval eval \${$_source_set[SKIPPED_LIST_CMD]}; }
_failed_list_command   () { eval eval \${$_source_set[FAILED_LIST_CMD]}; }
eval "local _skipped_rtn_name=\"\${$_source_set[SKIPPED_RTN_NAME]:-}\""
eval "local _executed_rtn_name=\"\${$_source_set[EXECUTED_RTN_NAME]:-}\""
eval "local _failed_rtn_name=\"\${$_source_set[FAILED_RTN_NAME]:-}\""

Is_True ${_force} && _choice=${_default_choice} || _choice=
for _item in $_list
do
    if ! Is_True ${_force}; then
        Query "${_query_string}" _force && _choice=true || _choice=false
    fi
    if Is_True ${_choice}; then
        if _action_command
        then
            _executed_list+="${_item} "
            _executed_command
        else
            _failed_list+="${_item} "
            _failed_command
        fi
    else
        _skipped_list+="${_item} "
        _skipped_command
    fi
done
local _output
for _output in executed skipped failed
do
_output_list_name="_${_output}_list"
_output_rtn_name="_${_output}_rtn_name"
if  [[ -n "${!_output_list_name:-}" ]]; then
    [[ -n ${!_output_rtn_name:-} ]] && eval ${!_output_rtn_name}=\"\${_${_output}_list}\"
    eval _${_output}_list_command
fi
done
}
