#!/bin/bash

TestFunc ()
{
    return
    exit
}

# ----------------------------------------------------------------------
# REQUIRES
# ----------------------------------------------------------------------
# requires:
# wget
# packer (can install automatically)

# ----------------------------------------------------------------------
# STYLE GUIDE
# ----------------------------------------------------------------------
# avoid changing global state inside functions; prefer to return echo'd
#        values or set indirect variable names (not always possible)
# Global_Functions_Camel_Case_No_Leading_Underscore
# _Local_Functions_Camel_Case_o_Leading_Underscore
# GLOBALS in all caps
# globals that used to retrieve results from functions (pseudo local)
#        all lower case; should be unset after use this temporary use
# _local variables, lowercase leading underscore
# ASSOCIATIVE_ARRAYS_[NOTE_FINAL_UNDERSCORE]
# bracket all ${variables} for consistency

# ----------------------------------------------------------------------
# ENFORCE STYLES
# ----------------------------------------------------------------------
# scan for _locals outside of a function
# scan for _Local_Functions outside of a function
# scan for temp_globals that aren't unset
# scan for Camel_Case in function declarations

# ----------------------------------------------------------------------
# SCRIPT EXECUTION SETTINGS
# ----------------------------------------------------------------------

SCRIPTNAME="$(basename $0)"
DEBUG=${DEBUG:-}
set -o nounset # -u : disallow unset variable use
set -o errexit # -e : exit on any trivial error
[[ -z $DEBUG ]] || set -o verbose # -v : talkative bash DEBUG

# ----------------------------------------------------------------------
# USER DEFAULTS
# ----------------------------------------------------------------------
# Don't change these here. Set in your shell's environment variables.

# Snapshot directory. Override this in your environment with PACSNAP_DIRECTORY
DEFAULT_SNAPSHOT_DIRPATH="${PACSNAP_DIRECTORY:-${XDG_CONFIG_HOME}/${SCRIPTNAME}/${HOSTNAME}}"

# AUR helper. Override with in your environment with AUR_HELPER
# must support basic pacman command line options (-S, -Q, etc.)
AUR_HELPER=${AUR_HELPER:-packer}

# ----------------------------------------------------------------------
# SCRIPT DEFAULTS
# ----------------------------------------------------------------------

LIBS_DIRPATH="/usr/share/${SCRIPTNAME}/lib"
LIBS_DIRPATH="$(dirname $0)/lib" # TODO: remove this
CMDLINE_OPTIONS="${@}" # global so we can use in functions easily
INSTALL_BACKUP_SUFFIX=".${SCRIPTNAME}" # cf man install
INSTALL_BACKUP_MODE=simple # cf man install

# ----------------------------------------------------------------------
# DYNAMIC ASSOCIATIVE ARRAYS
# ----------------------------------------------------------------------
# This allows associative arrays to be used like normal bash variables without 
# explicitly declaring them if the are suffixed by an underscore:
# I_AM_AN_ASSOCIATIVE_ARRAY_[INDEED]
# Note: evaluated variable names ( eval I_MAY_${BE_AN_ASSOC}_[ARRAY] ) will not 
# be detected by this unless referenced somewhere else in its full form.
# TODO: only the first associative arary on a line will be detected; improve.

for filename in $0 $LIBS_DIRPATH/*; do
for assoc_array in $(egrep '^[^#]*_(\[.*\])?[+=]' $filename | sed \
    's/\(^\|^.*\W\)\(\w*_\)[\[\=\].*/\2/' | sort | uniq)
    do eval "declare -A $assoc_array"; done; done; unset filename

# ----------------------------------------------------------------------
# SNAPSHOT FILENAMES
# ----------------------------------------------------------------------

PACKAGES_[FILENAME]="packages"
AUR_[FILENAME]="aur"
OVERLAY_[FILENAME]="overlay"
OVERLAY_[DIRNAME]="${OVERLAY_[FILENAME]}.d"

# ----------------------------------------------------------------------
# LIBS
# ----------------------------------------------------------------------

for filename in $LIBS_DIRPATH/* ; do source $filename; done; unset filename

# ----------------------------------------------------------------------
# COMMAND LINE OPTIONS, RUNTIME OPTION REPORT VALUES & HELP
# ----------------------------------------------------------------------

OPT_BACKUP_=(
[FLAG]='b'
[STATE]='true'
[STATE_SET]='false'
[ALERT]='Backups OFF; Files will be overwritten.'
[ALERT_SET]='Backups ON; Files will be saved in place with backup suffix.'
[USAGE]='Backup files when copying new file to existing path.'
)
OPT_FORCE_=(
[FLAG]='f'
[STATE]='false'
[STATE_SET]='true'
[ALERT]='Force mode OFF; Prompt before file write operations.'
[ALERT_SET]='Force mode ON; No prompts presented (CAUTION).'
[USAGE]='Force all write operations; no prompts will be given.'
)
OPT_GIT_UPDATE_=(
[FLAG]='g'
[STATE]='false'
[STATE_SET]='true'
[ALERT]='Git update OFF; No git push after config update.'
[ALERT_SET]='Git update ON; Git push will occur after config update.'
[USAGE]='Git commit and push snapshot directory if it is a repository.'
)
OPT_PACMAN_UPDATE_=(
[FLAG]='y'
[STATE]='false'
[STATE_SET]='true'
[ALERT]='Pacman update OFF; Package list will not be refreshed.'
[ALERT_SET]='Pacman update ON; Package list will be downloaded.'
[USAGE]='Update pacman package master list (pacman -Sy).'
)
OPT_SNAPSHOT_DIRPATH_=(
[FLAG]='p:'
[STATE]="${DEFAULT_SNAPSHOT_DIRPATH}"
[STATE_SET]=''
[ALERT]="Custom snapshot path OFF; Path is ${DEFAULT_SNAPSHOT_DIRPATH}."
[ALERT_SET]='Custom snapshot path ON; Path is ${SNAPSHOT_DIRPATH}.'
[USAGE]='Specify full path to a custom snapshot directory.'
)
OPT_SYSTEM_RESTORE_=(
[FLAG]='s'
[STATE]='false'
[STATE_SET]='true'
[CONFLICTS]='SNAPSHOT_UPDATE'
[ALERT]='System update OFF; No system files will be updated.'
[ALERT_SET]='System update ON; Live system files will be overwritten.'
[USAGE]='Update LIVE system files/packages from snapshot.'
[WARN_CONDITION]='FORCE'
[WARNING]='
$SCRIPTNAME SYSTEM RESTORE being run in FORCE OVERWRITE mode:

* All snapshot packages will be installed.
* Packages not listed in the snapshot will be removed.
* New group packages will be installed.
* Group packages no longer in a group will be removed.
* Overlay files will be replaced automatically.

Use the backup option to save current files (not packages) prior to overlay.'
)
OPT_SNAPSHOT_UPDATE_=(
[FLAG]='u'
[STATE]='false'
[STATE_SET]='true'
[ALERT]='Snapshot update OFF; Snapshot files will not be updated.'
[ALERT_SET]='Snapshot update ON; Updated files saved to ${SNAPSHOT_DIRPATH}.'
[USAGE]='Update files in snapshot directory.'
[WARN_CONDITION]='FORCE'
[WARNING]='
$SCRIPTNAME SNAPSHOT UPDATE being run in FORCE OVERWRITE mode:

* Packages in the snapshot but not installed will be removed from the snapshot.
* Installed packages not listed in the snapshot will be added to the snapshot.
* Overlay files listed in the snapshot will be saved in the snapshot directory.

Use the backup option to save the current snapshot files (package lists and 
overlay list and files) prior to the new snapshot creation.'
)

# ----------------------------------------------------------------------
# EXECUTION SEQUENCE
# ----------------------------------------------------------------------

UNIT_SEQUENCE="
PrepareEnvironment
InitializeOptions
InitializeSnapshotState
InitializeSystemState
InitializeStateDifferential
UpdateSnapshot
UpdateSystem
ReportResults
CleanUpEnvironment
"
UNIT_SEQUENCE="
PrepareEnvironment
InitializeOptions
InitializeSnapshotState
InitializeSystemState
ReportResults
CleanUpEnvironment
"

# ----------------------------------------------------------------------
# EXECUTION UNITS
# ----------------------------------------------------------------------

TRAP_Alert ()
{
    echo -e "\nEARLY TERMINATION: Running Cleanup...\n"
}

UNIT_PrepareEnvironment ()
{
trap 'TRAP_Alert; UNIT_ReportResults; UNIT_CleanUpEnvironment' INT TERM EXIT
TMPDIR="$(mktemp -d --tmpdir $SCRIPTNAME.XXX)"; CLEANUP+=('rm -rf $TMPDIR')
Install_Package_From_AUR "$AUR_HELPER"

# TODO: check config directory

}

UNIT_InitializeOptions ()
{
Options_Initialize || Fail_Critically "Error initializing options."
local _option_summary="$(Options_Summary)"
local _option_warning="$(Options_Warning)"
[[ -z ${_option_summary:-} ]] || UI_Passive_Alert "$SCRIPTNAME\n\n${_option_summary}"
[[ -z ${_option_warning:-} ]] || UI_Active_Warning "${_option_warning}"
}

UNIT_InitializeSnapshotState ()
{
# locate/make snapshot directory if in update snapshot mode, otherwise warn 
# user and exit
if [[ ! -d "${SNAPSHOT_DIRPATH}" ]]
then
    if Is_True ${SYSTEM_RESTORE}
    then
        local _alert=
        if [[ "${SNAPSHOT_DIRPATH}" == "${DEFAULT_SNAPSHOT_DIRPATH}" ]]
        then
        _alert+="No snapshot directory found at default path ${SNAPSHOT_DIRPATH}.
        Please run ${SCRIPTNAME} again in snapshot update mode (command line 
        flag: -${OPT_SNAPSHOT_UPDATE_[FLAG]%:}) to automatically create 
        a snapshot directory at this default location. Alternately, locate an 
        existing snapshot directory (using the  
        -${OPT_SNAPSHOT_DIRPATH_[FLAG]%:} <custompath> command line option)."
        else
        _alert="No snapshot directory found at custom path ${SNAPSHOT_DIRPATH}.
        Please run ${SCRIPTNAME} again in snapshot update mode (command line 
        flag: -${OPT_SNAPSHOT_UPDATE_[FLAG]%:}) to automatically create 
        a snapshot directory at this custom location. Alternately, run again 
        without the -${OPT_SNAPSHOT_DIRPATH_[FLAG]%:} <custompath> option to 
        attempt to use the default snapshot directory 
        (${DEFAULT_SNAPSHOT_DIRPATH})."
        fi
        UI_Passive_Warning "$(echo -e ${_alert})"
        exit 0
    else
        mkdir -p ${SNAPSHOT_DIRPATH}
        Unit_Report "Using snapshot directory at ${SNAPSHOT_DIRPATH}"
    fi
fi

PACKAGES_[FILEPATH]="${SNAPSHOT_DIRPATH}/${PACKAGES_[FILENAME]}"
AUR_[FILEPATH]="${SNAPSHOT_DIRPATH}/${AUR_[FILENAME]}"
OVERLAY_[FILEPATH]="${SNAPSHOT_DIRPATH}/${OVERLAY_[FILENAME]}"
OVERLAY_[DIRPATH]="${SNAPSHOT_DIRPATH}/${OVERLAY_[DIRNAME]}"

OVERLAY_[FILE]=\
"$(Read_File_Drop_Comments ${OVERLAY_[FILEPATH]})"
PACKAGES_[FILE]=\
"$(Read_File_Drop_Comments ${PACKAGES_[FILEPATH]} | Normalize_To_List)"
AUR_[FILE]=\
"$(Read_File_Drop_Comments ${AUR_[FILEPATH]} | Normalize_To_List)"

if Is_True $DEBUG
then
Unit_Report "\nLOADED PACKAGES FILE from ${PACKAGES_[FILEPATH]}:"
Unit_Report "$(echo ${PACKAGES_[FILE]})"
Unit_Report "\nLOADED AUR FILE from ${AUR_[FILEPATH]}:"
Unit_Report "$(echo ${AUR_[FILE]})"
Unit_Report "\nLOADED OVERLAY FILE from ${OVERLAY_[FILEPATH]}:"
Unit_Report "${OVERLAY_[FILE]}"
fi

[[ -n ${OVERLAY_[FILE]} ]] \
|| Unit_Report "No overlay file list. To save a snapshot of specific system 
configuration files, make a line by line list of file paths in the following 
file: ${OVERLAY_[FILEPATH]}"

}

UNIT_InitializeSystemState ()
{

# DETECT GROUPS
# ----------------------------------------------------------------------
GROUPS_[POTENTIAL]=$(pacman -Qg | awk '{print $1}' | sort -u)
UI_Incremental_Alert "\nDetecting installed groups... "
if Is_True $DEBUG
then
    GROUPS_[DETECTED]="base base-devel xfce4 xorg xorg-apps xorg-drivers xorg-fonts" #DEBUG
else
    local _group
    for _group in ${GROUPS_[POTENTIAL]}
    do
        # get percentage of group already installed
        # sort -u required (via Normalize_To_List) as there can be duplicate package 
        # reporting if testing repos are live, for instance
        GROUP_PACKAGES_LOCAL_[${_group}]="$(pacman -Qgq $_group)"
        GROUP_PACKAGES_REPO_[${_group}]="$(pacman -Sgq $_group)"
        local _group_count_local=$(echo ${GROUP_PACKAGES_LOCAL_[${_group}]} \
            | Normalize_To_List | wc -l)
        local _group_count_repo=$(echo ${GROUP_PACKAGES_REPO_[${_group}]} \
            | Normalize_To_List | wc -l)
        local _threshold=12
        local _score=$(echo $((($_group_count_repo*10)/$_group_count_local)))
        if [[ $_score -le $_threshold ]]
        then
            GROUPS_[DETECTED]+="$_group "
            UI_Incremental_Alert "$_group "
        fi
    done
    UI_Incremental_Alert # finishes the incremental alert line
fi
Unit_Report "FULLY INSTALLED GROUPS (DETECTED):\n${GROUPS_[DETECTED]}"

# CHECK GROUP FOR NEW/REMOVED PACKAGES
# ----------------------------------------------------------------------
local _group
for _group in ${GROUPS_[DETECTED]}
do
    GROUP_PACKAGES_MISSING_IN_GROUP_[$_group]=$(Set_Op_Difference \
        "${GROUP_PACKAGES_LOCAL_[${_group}]}" \
        "${GROUP_PACKAGES_REPO_[${_group}]}")
    exit
    GROUP_PACKAGES_REMOVED_FROM_GROUP_[$_group]=$(Set_Op_Difference \
        "${GROUP_PACKAGES_REPO_[${_group}]}" \
        "${GROUP_PACKAGES_LOCAL_[${_group}]}")
    echo ">>>>> ${_group} >>> ${GROUP_PACKAGES_MISSING_IN_GROUP_[$_group]}"
    [[ -z ${GROUP_PACKAGES_MISSING_IN_GROUP_[$_group]:-} ]] \
    || Unit_Report "\nPACKAGES ADDED TO GROUP "${_group}" BUT NOT INSTALLED ON LIVE SYSTEM:\n$(echo ${GROUP_PACKAGES_MISSING_IN_GROUP_[$_group]})"
    [[ -z ${GROUP_PACKAGES_REMOVED_FROM_GROUP_[$_group]:-} ]] \
    || Unit_Report "\nPACKAGES CURRENTLY INSTALLED AS PART OF GROUP "${_group}" HAVE SINCE BEEN REMOVED FROM GROUP:\n$(echo ${GROUP_PACKAGES_REMOVED_FROM_GROUP_[$_group]})"
done

# PACKAGE STATE
# ----------------------------------------------------------------------

UI_Passive_Alert "Getting list of explicitly installed packages"
# TODO: deal with timeline of updating the group packages
#PACKAGES_LOCAL_[ALLGROUPS]="$(pacman -Qgq | Normalize_To_List)"
local _packages_groups="$(echo "${GROUP_PACKAGES_LOCAL_[*]}" | Normalize_To_List)"
local _packages_explicit="$(pacman -Qeq)"
local _packages_manual="$(pacman -Qmq)"
local _packages_repo="$(Set_Op_Difference "${_packages_explicit}" "${_packages_manual}")"
local _packages_noaur="$(Set_Op_Difference "${_packages_explicit}" "${_packages_manual}")"
PACKAGES_[LIVE]="$(Set_Op_Difference "${_packages_repo}" "${_packages_groups}")"
AUR_[LIVE]="$(Set_Op_Intersection "${_packages_explicit}" "${_packages_manual}")"

PACKAGES_MISSING_IN_[LIVE]="$(Set_Op_Difference "${PACKAGES_[FILE]}" "${PACKAGES_[LIVE]}")"
PACKAGES_MISSING_IN_[FILE]="$(Set_Op_Difference "${PACKAGES_[LIVE]}" "${PACKAGES_[FILE]}")"
AUR_MISSING_IN_[LIVE]="$(Set_Op_Difference "${AUR_[FILE]}" "${AUR_[LIVE]}")"
AUR_MISSING_IN_[FILE]="$(Set_Op_Difference "${AUR_[LIVE]}" "${AUR_[FILE]}")"

Unit_Report "\nOFFICIAL PACKAGES (EXCL. DEPENDENCIES, NO GROUP PACKAGES):"
Unit_Report ${PACKAGES_[LIVE]:-NONE}
Unit_Report "\nAUR PACKAGES (EXCL. DEPENDENCIES):"
Unit_Report ${AUR_[LIVE]:-NONE}

[[ -z ${PACKAGES_MISSING_IN_[LIVE]:-} ]] \
|| Unit_Report "\nSNAPSHOT PACKAGES NOT INSTALLED ON LIVE SYSTEM:
$(echo ${PACKAGES_MISSING_IN_[LIVE]})"

[[ -z ${AUR_MISSING_IN_[LIVE]:-} ]] \
|| Unit_Report "\nSNAPSHOT AUR PACKAGES NOT INSTALLED ON LIVE SYSTEM:
${AUR_MISSING_IN_[LIVE]})"

[[ -z ${PACKAGES_MISSING_IN_[FILE]:-} ]] \
|| Unit_Report "\nPACKAGES INSTALLED ON LIVE SYSTEM BUT NOT IN SNAPSHOT:
$(echo ${PACKAGES_MISSING_IN_[FILE]})"

[[ -z ${AUR_MISSING_IN_[FILE]:-} ]] \
|| Unit_Report "\nAUR PACKAGES INSTALLED ON LIVE SYSTEM BUT NOT IN SNAPSHOT:
$(echo ${AUR_MISSING_IN_[FILE]})"

# OVERLAY FILE CHECK
# ----------------------------------------------------------------------

# state of overlay files list from snapshot:
# - missing (no current snapshot directory)
# - missing (snapshot doesn't have an overlay list)
# - present but handbuilt (no permissions or ownership, just paths)
# - present and correctly formed
#
# Here we scan through the overlay list if we have it, compare against current 
# system values and do the following:
# - normalize the overlay list format listing in memory, filling in missing
#   permissions and ownership values from the live system if file is present
#   and from the default attribs value if no file is on the live system
# - record the names of any missing system files listed in the config for
#   report purposes
# - record the names and report the diff value of any files that differ from
#   the live system

UI_Passive_Alert "Checking overlay files"
DEFAULT_ATTRIBS="644 root root"

_IFS=$IFS; IFS=$'\n'
for line in ${OVERLAY_[FILE]}
do
    _path=$(echo -n $line | awk '{print $1}')
    _attribs=$(echo -n $line | awk '{print $2,$3,$4}')
    [[ -e $_path ]] && _live_attribs=$(stat -c '%a %U %G' $_path)
    [[ -z $_attribs && -e $_path ]] && _attribs=$_live_attribs
    #TODO: may be better to not set default values in case of no current live file
    #[[ -z $_attribs ]] && _attribs=$DEFAULT_ATTRIBS
    overlay_files[reviewed]+="$_path $_attribs\n"
    [[ -e $_path ]] && overlay_files[live]+="$_path $_live_attribs\n" || overlay_files[live]+="$_path $_attribs\n"
    overlay_files[paths]+="$_path\n"
done
IFS=$_IFS
overlay_files[file]="$(echo -e "${overlay_files[reviewed]}" | sed '/^$/d')"
overlay_files[live]="$(echo -e "${overlay_files[live]}" | sed '/^$/d')"
overlay_files[paths]="$(echo -e "${overlay_files[paths]}" | sed '/^$/d')"
overlay_files[diff]="$(compare "${overlay_files[live]}" "${overlay_files[file]}")"
report overlay "Overlay file list:"
report overlay "${overlay_files[file]}"
if [[ -n ${overlay_files[diff]} ]]
then
    report overlay "\nOverlay file items that differ from the live system"
    report overlay "${overlay_files[diff]}"
fi

}

UNIT_UpdateSnapshot ()
{
$(Is_True $UPDATE_SNAPSHOT) || return
# use differential to update snapshot state
# prompting unless in force mode
# (herein it's pseudo functional)

}

UNIT_UpdateSystem ()
{
$(Is_True $UPDATE_SYSTEM) || return
# use differential to update system state
# prompting unless in force mode
# (herein it's pseudo functional)
# regen / user regen

}

UNIT_ReportResults ()
{
# trap was previously ReportResults plus CleanUpEnvironment; if we're 
# here and have a critical failure then we must of course reassign our 
# trap to CleanUpEnvironment (which would have been called after 
# ReportResults)
trap 'UNIT_CleanUpEnvironment' INT TERM EXIT

if [[ -n ${REPORT_SEQUENCE_[@]:-} ]]
then
    for _report_category in "${REPORT_SEQUENCE_[@]:-}"
    do
        UI_Passive_Alert "$(Upper_Case $_report_category):"
        UI_Passive_Alert "${REPORT_[${_report_category}]}"
    done
fi

#each sequence unit should be creating a report in a standard format
#and adding to a global report sequence variable
}

UNIT_CleanUpEnvironment ()
{
trap - INT TERM EXIT
#remove temp dir
for cleanup_item in "${CLEANUP[@]}"; do eval "$cleanup_item"; done
}

#Safe_Execute ${UNIT_SEQUENCE}
for unit in $UNIT_SEQUENCE
do
    eval UNIT_$unit
done
unset unit




exit






