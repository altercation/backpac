#!/bin/bash

TestFunc ()
{
    :
}

# ----------------------------------------------------------------------
# REQUIRES
# ----------------------------------------------------------------------
# requires:
# wget
# packer (can install automatically)

# ----------------------------------------------------------------------
# STYLE GUIDE
# ----------------------------------------------------------------------
# avoid changing global state inside functions; prefer to return echo'd
#        values or set indirect variable names (not always possible)
# Global_Functions_Camel_Case_No_Leading_Underscore
# _Local_Functions_Camel_Case_o_Leading_Underscore
# GLOBALS in all caps
# globals that used to retrieve results from functions (pseudo local)
#        all lower case; should be unset after use this temporary use
# _local variables, lowercase leading underscore
# ASSOCIATIVE_ARRAYS_[NOTE_FINAL_UNDERSCORE]
# bracket all ${variables} for consistency

# ----------------------------------------------------------------------
# ENFORCE STYLES
# ----------------------------------------------------------------------
# scan for _locals outside of a function
# scan for _Local_Functions outside of a function
# scan for temp_globals that aren't unset
# scan for Camel_Case in function declarations

# ----------------------------------------------------------------------
# SCRIPT EXECUTION SETTINGS
# ----------------------------------------------------------------------

SCRIPTNAME="$(basename $0)"
DEBUG=${DEBUG:-}
set -o nounset # -u : disallow unset variable use
set -o errexit # -e : exit on any trivial error
[[ -z $DEBUG ]] || set -o verbose # -v : talkative bash DEBUG

# ----------------------------------------------------------------------
# SCRIPT DEFAULTS
# ----------------------------------------------------------------------

LIBS_DIRPATH="/usr/share/${SCRIPTNAME}/lib"
LIBS_DIRPATH="$(dirname $0)/lib" # TODO: remove this
CMDLINE_OPTIONS="${@}" # global so we can use in functions easily
BACKUP_SUFFIX=".${SCRIPTNAME}" # cf man install
DEFAULT_BACKUP_MODE=simple # cf man install
PACKAGES_FILENAME="packages"
AUR_FILENAME="aur"
OVERLAY_FILENAME="overlay"
OVERLAY_DIRNAME="${OVERLAY_FILENAME}.d"

# ----------------------------------------------------------------------
# DYNAMIC ASSOCIATIVE ARRAYS
# ----------------------------------------------------------------------
# This allows associative arrays to be used like normal bash variables without 
# explicitly declaring them if the are suffixed by an underscore:
# I_AM_AN_ASSOCIATIVE_ARRAY_[INDEED]
# Note: evaluated variable names ( eval I_MAY_${BE_AN_ASSOC}_[ARRAY] ) will not 
# be detected by this unless referenced somewhere else in its full form.
# TODO: only the first assoc array on a line will be declared. Currently the 
# variable name can only be prefixed by non-word characters
# NOTE: "line: xxx: NAME: unbound variable errors are likely because an 
# associative array isn't being detected (usually forgot to use a trailing 
# underscore).
# nb: the sed is a bit ugly but it's compensating for sed's natural greediness

for filename in $0 $LIBS_DIRPATH/*; do
for assoc_array in $(egrep '^[^#]*_(\[.*\])?[+=]' $filename \
    | sed 's/\W*\(\W*\)\(\w\+_\)[\[\=\].*/\1-----\2/' \
    | sed 's/.*-----\(.*\)/\1/' | sort -u)
    do
        eval "declare -A $assoc_array";
    done;
done; unset filename

# ----------------------------------------------------------------------
# LIBS
# ----------------------------------------------------------------------

for filename in $LIBS_DIRPATH/* ; do source $filename; done; unset filename

# ----------------------------------------------------------------------
# TEST FUNCTION
# ----------------------------------------------------------------------

TestFunc

# ----------------------------------------------------------------------
# USER DEFAULTS
# ----------------------------------------------------------------------
# Don't change these here. Set in your shell's environment variables.

# Snapshot directory. Override this in your environment with ${SCRIPTNAME}_DIRECTORY
eval SNAPSHOT_DIRNAME_ENVVAR="$(Upper_Case $SCRIPTNAME)_DIR"
DEFAULT_SNAPSHOT_DIRPATH="${!SNAPSHOT_DIRNAME_ENVVAR:-${XDG_CONFIG_HOME}/${SCRIPTNAME}/${HOSTNAME}}"

# AUR helper. Override with in your environment with AUR_HELPER
# must support basic pacman command line options (-S, -Q, etc.)
AUR_HELPER=${AUR_HELPER:-packer}

# ----------------------------------------------------------------------
# COMMAND LINE OPTIONS, RUNTIME OPTION REPORT VALUES & HELP
# ----------------------------------------------------------------------

OPT_FORCE_=(
[FLAG]='f'
[STATE]='false'
[STATE_SET]='true'
[ALERT]='Force mode OFF; Prompt before file write operations.'
[ALERT_SET]='Force mode ON; No prompts presented (CAUTION).'
[USAGE]='Force all write operations; no prompts will be given.'
[PRERUN]=''
)
OPT_FULL_FORCE_=(
[FLAG]='F'
[STATE]='false'
[STATE_SET]='true'
[ALERT]='Full Force mode OFF; No automatic uninstalls.'
[ALERT_SET]='Full Force mode ON; Automatic uninstalls.'
[USAGE]='DANGER: Force mode with automatic execution, NO-INITIAL PROMPT.'
)
OPT_GROUP_CURRENCY_CHECK_=(
[FLAG]='G'
[STATE]='true'
[STATE_SET]='false'
[ALERT]='Suppress group check OFF; Groups will be checked for currency.'
[ALERT_SET]='Suppress group check ON; Groups will not be checked for currency.'
[USAGE]='Suppress group currency check; Skip checking current group packages.'
)
OPT_OVERLAY_DIFF_DISPLAY_=(
[FLAG]='d'
[STATE]='false'
[STATE_SET]='true'
[ALERT]='Overlay file diff OFF; No file diff report will be displayed.'
[ALERT_SET]='Overlay file diff ON; File diff report will be displayed.'
[USAGE]='Overlay files will be diffed with system files and result displayed.'
)
OPT_GIT_UPDATE_=(
[FLAG]='g'
[STATE]='false'
[STATE_SET]='true'
[ALERT]='Git update OFF; No git push after config update.'
[ALERT_SET]='Git update ON; Git push will occur after config update.'
[USAGE]='Git commit and push snapshot directory if it is a repository.'
)
OPT_PACMAN_UPDATE_=(
[FLAG]='y'
[STATE]='false'
[STATE_SET]='true'
[ALERT]='Pacman update OFF; Package list will not be refreshed.'
[ALERT_SET]='Pacman update ON; Package list will be downloaded.'
[USAGE]='Update pacman package master list (pacman -Sy).'
)
OPT_SNAPSHOT_DIRPATH_=(
[FLAG]='p:'
[STATE]="${DEFAULT_SNAPSHOT_DIRPATH}"
[STATE_SET]=''
[ALERT]="Custom snapshot path OFF; Path is ${DEFAULT_SNAPSHOT_DIRPATH}."
[ALERT_SET]='Custom snapshot path ON; Path is ${SNAPSHOT_DIRPATH}.'
[USAGE]='Specify full path to a custom snapshot directory.'
)
OPT_SYSTEM_UPDATE_=(
[FLAG]='s'
[STATE]='false'
[STATE_SET]='true'
[CONFLICTS]='SNAPSHOT_UPDATE'
[ALERT]='System update OFF; No system files will be updated.'
[ALERT_SET]='System update ON; Live system files will be overwritten.'
[USAGE]='Update LIVE system files/packages from snapshot.'
[PRERUN_CONDITIONALS]='FORCE'
[PRERUN]='SYSTEM UPDATE MODE will PROMPT for the following:

* install snapshot packages
* uninstall packages not in snapshot
* install new group packages
* remove old group packages
* install overlay files to system'
[PRERUN_FORCE]='SYSTEM UPDATE (FORCE) MODE will AUTOMATICALLY execute:

* install snapshot packages
* uninstall packages not in snapshot
* install new group packages
* remove old group packages
* install overlay files to system'
)
OPT_SNAPSHOT_UPDATE_=(
[FLAG]='u'
[STATE]='false'
[STATE_SET]='true'
[ALERT]='Snapshot update OFF; Snapshot files will not be updated.'
[ALERT_SET]='Snapshot update ON; Updated files saved to ${SNAPSHOT_DIRPATH}.'
[USAGE]='Update files in snapshot directory.'
[PRERUN_CONDITIONALS]='FORCE'
[PRERUN]='SNAPSHOT UPDATE MODE will PROMPT for the following:

* Packages in the snapshot but not installed will be removed from the snapshot.
* Installed packages not listed in the snapshot will be added to the snapshot.
* Overlay files listed in the snapshot will be saved in the snapshot directory.'
[PRERUN_FORCE]='SNAPSHOT UPDATE (FORCE) MODE will AUTOMATICALLY execute:

* Packages in the snapshot but not installed will be removed from the snapshot.
* Installed packages not listed in the snapshot will be added to the snapshot.
* Overlay files listed in the snapshot will be saved in the snapshot directory.'
)
OPT_BACKUP_MODE_=(
[FLAG]='B'
[STATE]="${DEFAULT_BACKUP_MODE}"
[STATE_SET]='none'
[ALERT]='Backups ON; Files will be saved in place with backup suffix.'
[ALERT_SET]='Backups OFF; Files will be overwritten.'
[USAGE]='Turn off backups when copying new files to an existing path.'
[PRERUN_CONDITIONALS]='SYSTEM_UPDATE SNAPSHOT_UPDATE'
[PRERUN_SYSTEM_UPDATE]='WARNING: SYSTEM FILES WILL BE OVERWRITTEN WITHOUT BACKUP.'
[PRERUN_SNAPSHOT_UPDATE]='WARNING: SNAPSHOT FILES WILL BE OVERWRITTEN WITHOUT BACKUP.'
)
OPT_HELP_=(
[FLAG]='h'
[STATE]='false'
[STATE_SET]='true'
[ALERT]='Display option and usage summary.'
[USAGE]='${OPT_HELP_[ALERT]}'
)
USAGE_SYSTEM_CONFIG="CURRENT DEFAULT PATH=${DEFAULT_SNAPSHOT_DIRPATH} Change this with -${OPT_SNAPSHOT_DIRPATH_[FLAG]} command line option or by setting an environment variable named ${SNAPSHOT_DIRNAME_ENVVAR} to your preferred custom path.\nCURRENT AUR HELPER=${AUR_HELPER} Change this by setting an environment variable named AUR_HELPER to your preferred application. Must support basic pacman options. Will be installed by ${SCRIPTNAME} if not present."
USAGE_SUMMARY='
NOTE: Running without options will execute ${SCRIPTNAME} in a safe, passive report mode.  No changes to either the snapshot lists or the live system will be made.

${SCRIPTNAME} manages package and configuration files using a few simple lists.  

    ${PACKAGES_FILENAME}
    ${AUR_FILENAME}
    ${OVERLAY_FILENAME}

The \"${PACKAGES_FILENAME}\" and \"${AUR_FILENAME}\" files are just a long list of package names that you either have or wish to install expclicitly on your current system.

The \"${OVERLAY_FILENAME}\" list can be initially created as a \"one-path-per-line\" list of files you wish to save a copy of in an \"${OVERLAY_DIRNAME}\" directory. These can then be used as a snapshot of, for example, system configuration state.

${SCRIPTNAME} runs in three modes:

    Passive report mode: Displays a summary of your list and system state
    Snapshot update mode: Updates your lists of packages and overlay files
    System conform mode: Conforms current system state to match snapshot

Unless running with the \"force\" option, a prompt will be displayed prior to any data changing event, in each of the three modes.
'

# ----------------------------------------------------------------------
# EXECUTION SEQUENCE
# ----------------------------------------------------------------------

UNIT_SEQUENCE="
Prepare_Environment
Initialize_Options
Snapshot
Groups
Packages
Overlay
Report
Clean_Up
"

# ----------------------------------------------------------------------
# EXECUTION UNITS
# ----------------------------------------------------------------------

TRAP_Alert ()
{
    # echo -e "\nEARLY TERMINATION: Running Cleanup...\n"
    :
}

UNIT_Prepare_Environment ()
{
trap 'TRAP_Alert; UNIT_Report; UNIT_Clean_Up' INT TERM EXIT
TMPDIR="$(mktemp -d --tmpdir $SCRIPTNAME.XXX)"; CLEANUP+=('rm -rf $TMPDIR')
Install_Package_From_AUR "$AUR_HELPER"
}

UNIT_Initialize_Options ()
{
# initialize options from OPT_ arrays
Options_Initialize || Fail_Critically "Error initializing options."

# final path set based on options
PACKAGES_FILEPATH="${SNAPSHOT_DIRPATH}/${PACKAGES_FILENAME}"
AUR_FILEPATH="${SNAPSHOT_DIRPATH}/${AUR_FILENAME}"
OVERLAY_FILEPATH="${SNAPSHOT_DIRPATH}/${OVERLAY_FILENAME}"
OVERLAY_DIRPATH="${SNAPSHOT_DIRPATH}/${OVERLAY_DIRNAME}"

# set force if full force
Is_True ${FULL_FORCE} && FORCE=true

# set execution mode
if ! Is_True ${SYSTEM_UPDATE:-} && ! Is_True ${SNAPSHOT_UPDATE:-}
then MODE=REPORT
elif Is_True ${SNAPSHOT_UPDATE:-}
then MODE=SNAPSHOT
elif Is_True ${SYSTEM_UPDATE:-}
then MODE=SYSTEM
else
    UI_Passive_Alert "FAILED TO DETECT KNOWN EXECUTION MODE"; exit 1
fi

# options summary and prerun alert
local _option_summary="$(Options_Summary)"
local _option_prerun="$(Options_Prerun)"
[[ -z ${_option_summary:-} ]] || UI_Passive_Alert "\n$SCRIPTNAME\n\n${_option_summary}"
[[ -z ${_option_prerun:-} ]] || Query "\n${_option_prerun}\n\nProceed?"
}

UNIT_Snapshot ()
{
# locate/make snapshot directory if in update snapshot mode, otherwise warn 
# user and exit
if [[ ! -d "${SNAPSHOT_DIRPATH}" ]]
then
    if Is_True ${SYSTEM_UPDATE}
    then
        local _alert=
        if [[ "${SNAPSHOT_DIRPATH}" == "${DEFAULT_SNAPSHOT_DIRPATH}" ]]
        then
        _alert+="No snapshot directory found at default path ${SNAPSHOT_DIRPATH}.
        Please run ${SCRIPTNAME} again in snapshot update mode (command line 
        flag: -${OPT_SNAPSHOT_UPDATE_[FLAG]%:}) to automatically create 
        a snapshot directory at this default location. Alternately, locate an 
        existing snapshot directory (using the  
        -${OPT_SNAPSHOT_DIRPATH_[FLAG]%:} <custompath> command line option)."
        else
        _alert="No snapshot directory found at custom path ${SNAPSHOT_DIRPATH}.
        Please run ${SCRIPTNAME} again in snapshot update mode (command line 
        flag: -${OPT_SNAPSHOT_UPDATE_[FLAG]%:}) to automatically create 
        a snapshot directory at this custom location. Alternately, run again 
        without the -${OPT_SNAPSHOT_DIRPATH_[FLAG]%:} <custompath> option to 
        attempt to use the default snapshot directory 
        (${DEFAULT_SNAPSHOT_DIRPATH})."
        fi
        UI_Passive_Warning "$(echo -e ${_alert})"
        exit 0
    else
        mkdir -p ${SNAPSHOT_DIRPATH}
    fi
fi
local _message="\nSourcing from snapshot directory: ${SNAPSHOT_DIRPATH}"
UI_Passive_Alert "$_message"
# if [[ "${MODE}" != "REPORT" ]] && ! Is_True ${FORCE}
# then
#     UI_Passive_Alert "$_message"
# fi
# Unit_Report "$_message"

PACKAGES_FILE="$(Read_File_Drop_Comments ${PACKAGES_FILEPATH} | Normalize_To_List)"
AUR_FILE="$(Read_File_Drop_Comments ${AUR_FILEPATH} | Normalize_To_List)"
#OVERLAY_FILE="$(Read_File_Drop_Comments ${OVERLAY_FILEPATH})"

#[[ -n ${OVERLAY_FILE} ]] \
#|| Unit_Report "No overlay file list. To save a snapshot of specific system 
#configuration files, make a line by line list of file paths in the following 
#file: ${OVERLAY_FILEPATH}"

}

UNIT_Groups ()
{

# DETECT GROUPS
# ----------------------------------------------------------------------
GROUPS_POTENTIAL=$(pacman -Qg | awk '{print $1}' | sort -u)
#UI_Incremental_Alert "\nDetecting installed groups... "
UI_Incremental_Alert "\nInitializing..."
local _group
for _group in ${GROUPS_POTENTIAL}
do
    # get percentage of group already installed
    # sort -u required (via Normalize_To_List) as there can be duplicate package 
    # reporting if testing repos are live, for instance
    GROUP_PACKAGES_LOCAL_[${_group}]="$(pacman -Qgq $_group)"
    GROUP_PACKAGES_REPO_[${_group}]="$(pacman -Sgq $_group)"
    local _group_count_local=$(echo ${GROUP_PACKAGES_LOCAL_[${_group}]} \
        | Normalize_To_List | wc -l)
    local _group_count_repo=$(echo ${GROUP_PACKAGES_REPO_[${_group}]} \
        | Normalize_To_List | wc -l)
    local _threshold=12
    local _score=$(echo $((($_group_count_repo*10)/$_group_count_local)))
    if [[ $_score -le $_threshold ]]
    then
        GROUPS_DETECTED+="$_group "
        #UI_Incremental_Alert "$_group "
        UI_Incremental_Alert ".."
    fi
done
#UI_Incremental_Alert # finishes the incremental alert line
UI_Passive_Alert " Done"
Unit_Report "INSTALLED GROUPS (DETECTED>80% MEMBER PACKAGE 
INSTALL):\n${GROUPS_DETECTED}"

# CHECK GROUP FOR NEW/REMOVED PACKAGES
# ----------------------------------------------------------------------

if Is_True ${GROUP_CURRENCY_CHECK}; then

# scan and build list of missing/removed
local _group
for _group in ${GROUPS_DETECTED}
do
    local _missing="$(Set_Op_Difference "${GROUP_PACKAGES_REPO_[$_group]}" "${GROUP_PACKAGES_LOCAL_[$_group]}")"
    if [[ -n ${_missing:-} ]]
    then
        GROUP_PACKAGES_MISSING_IN_GROUP_[${_group}]="${_missing%% *}"
    fi
    local _removed="$(Set_Op_Difference "${GROUP_PACKAGES_LOCAL_[${_group}]}" "${GROUP_PACKAGES_REPO_[${_group}]}")"
    if [[ -n ${_removed:-} ]]
    then
        GROUP_PACKAGES_REMOVED_FROM_GROUP_[${_group}]="${_removed%% *}"
    fi
done

local _runagain_alert="Run again in system update mode (non 
-${OPT_FORCE_[FLAG]} forced mode) to be presented a prompt for installation of 
these, or install manually."

local _skip_alert="Run ${SCRIPTNAME} with the 
-${OPT_GROUP_CURRENCY_CHECK_[FLAG]} command line option to skip this group 
package currency check."

if [[ -n "${GROUP_PACKAGES_MISSING_IN_GROUP_[*]:-}" ]]
then
    # there are some missing packages

    local _alert_intro="MISSING GROUP PACKAGES
    \nPackages currently included in group lists in repository but which are 
    missing from locally installed groups (for groups that have been fully 
    installed). Possibly indicates that groups have been updated in the 
    official repositories."

    if ! Is_True ${FORCE} && [[ "${MODE}" == "SYSTEM" ]]
    then
        # SYSTEM, NON FORCE MODE
            UI_Passive_Alert "${_alert_intro}"
            [[ -n ${_skip_alert} ]] && UI_Passive_Alert "${_skip_alert}\n"
            _skip_alert=
    else
        # REPORT, SNAPSHOT, OR SYSTEM-FORCE (don't auto install group pkgs?)
            Unit_Report "\n${_alert_intro}\n"
            [[ -n ${_runagain_alert} ]] && Unit_Report "${_runagain_alert}"
            [[ -n ${_skip_alert} ]] && Unit_Report "${_skip_alert}"
            [[ -n "${_skip_alert}${_runagain_alert}" ]] && Unit_Report ""
            _skip_alert=
            _runagain_alert=
    fi

    local _group
    for _group in ${!GROUP_PACKAGES_MISSING_IN_GROUP_[*]}; do
    if [[ -n "${GROUP_PACKAGES_MISSING_IN_GROUP_[$_group]}" ]]; then
    if ! Is_True ${FORCE} && [[ "${MODE}" == "SYSTEM" ]]; then
        UI_Passive_Alert "MISSING from group \"${_group}\":"

        Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
        [LIST_VAR_NAME]=''
        [LIST_VALUE]="${GROUP_PACKAGES_MISSING_IN_GROUP_[$_group]}"
        [QUERY_STRING]='Install ${_item}?'
        [ACTION_CMD]='Install_Package "${_item}"'
        [EXECUTED_CMD]=''
        [SKIPPED_CMD]=''
        [FAILED_CMD]=''
        [EXECUTED_LIST_CMD]='Unit_Report "MISSING from group \"${_group}\", INSTALLED: ${_executed_list}"'
        [SKIPPED_LIST_CMD]='Unit_Report "MISSING from group \"${_group}\", INSTALL SKIPPED: ${_skipped_list}"'
        [FAILED_LIST_CMD]='Unit_Report "MISSING from group \"${_group}\", INSTALL FAILED: ${_failed_list}"'
        [EXECUTED_RTN_NAME]=''
        [SKIPPED_RTN_NAME]=''
        [FAILED_RTN_NAME]=''
        [FORCE_VALUE]='${FORCE}'
        [DEFAULT_CHOICE]='${FULL_FORCE}'
        ); Ask_Auto_Action ASK_AUTO_SOURCE_
    else
        # not in non-force system update mode
        Unit_Report "MISSING from group \"${_group}\": ${GROUP_PACKAGES_MISSING_IN_GROUP_[$_group]}"
    fi; fi; done

    # regen packages list in case of changes to group packages
    # TODO: could check if changes were made, but this is a low cost procedure
    local _group
    for _group in ${GROUPS_DETECTED}
    do
        GROUP_PACKAGES_LOCAL_[${_group}]="$(pacman -Qgq $_group)"
        GROUP_PACKAGES_REPO_[${_group}]="$(pacman -Sgq $_group)"
    done

fi # end of test for any missing group packages

if [[ -n "${GROUP_PACKAGES_REMOVED_FROM_GROUP_[*]:-}" ]]
then
    # there are some removed packages

    local _alert_intro="REMOVED GROUP PACKAGES
    \nPackages that are currently installed via group package installation but 
    which have since been removed from group list in repository (for groups that 
    have been fully installed). Possibly indicates that groups have been updated in 
    the official repositories."

    if ! Is_True ${FORCE} && [[ "${MODE}" == "SYSTEM" ]]
    then
        # SYSTEM, NON FORCE MODE
        UI_Passive_Alert "${_alert_intro}"
        [[ -n ${_skip_alert} ]] && UI_Passive_Alert "${_skip_alert}\n"
        _skip_alert=
    else
        # REPORT, SNAPSHOT, OR SYSTEM-FORCE (don't auto install group pkgs?)
        Unit_Report "${_alert_intro}"
        [[ -n ${_runagain_alert} ]] && Unit_Report "${_runagain_alert}"
        [[ -n ${_skip_alert} ]] && Unit_Report "${_skip_alert}"
        _skip_alert=
        _runagain_alert=
    fi
    local _group
    for _group in ${!GROUP_PACKAGES_REMOVED_FROM_GROUP_[*]}; do
    if [[ -n "${GROUP_PACKAGES_REMOVED_FROM_GROUP_[$_group]}" ]]; then
    if ! Is_True ${FORCE} && [[ "${MODE}" == "SYSTEM" ]]; then
        # SYSTEM, NON FORCE MODE
        UI_Passive_Alert "REMOVED from group \"${_group}\":"

        Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
        [LIST_VAR_NAME]=''
        [LIST_VALUE]="${GROUP_PACKAGES_REMOVED_FROM_GROUP_[$_group]}"
        [QUERY_STRING]='Install ${_item}'
        [ACTION_CMD]='Uninstall_Package "${_item}?'
        [EXECUTED_CMD]=''
        [SKIPPED_CMD]=''
        [FAILED_CMD]=''
        [EXECUTED_LIST_CMD]='Unit_Report "REMOVED from repo group \"${_group}\", UNINSTALLED: ${_executed_list}"'
        [SKIPPED_LIST_CMD]='Unit_Report "REMOVED from repo group \"${_group}\", UNINSTALL SKIPPED: ${_skipped_list}"'
        [FAILED_LIST_CMD]='Unit_Report "REMOVED from repo group \"${_group}\", UNINSTALL FAILED: ${_failed_list}"'
        [EXECUTED_RTN_NAME]=''
        [SKIPPED_RTN_NAME]=''
        [FAILED_RTN_NAME]=''
        [FORCE_VALUE]='${FORCE}'
        [DEFAULT_CHOICE]='${FULL_FORCE}'
        ); Ask_Auto_Action ASK_AUTO_SOURCE_

    else
        Unit_Report "REMOVED from group \"${_group}\": ${GROUP_PACKAGES_REMOVED_FROM_GROUP_[$_group]}\n"
    fi; fi; done
fi # end of test for any removed group packages
fi # end of group currency check test
}

UNIT_Packages ()
{
# PACKAGE STATE
# ----------------------------------------------------------------------
Unit_Report "PACKAGES LIST (${PACKAGES_FILEPATH})"
Unit_Report "AUR LIST (${AUR_FILEPATH})"

#UI_Passive_Alert "Getting list of explicitly installed packages"

# TODO: deal with timeline of updating the group packages
#PACKAGES_LOCAL_ALLGROUPS="$(pacman -Qgq | Normalize_To_List)"

local _packages_groups="$(echo "${GROUP_PACKAGES_LOCAL_[*]}" | Normalize_To_List)"
local _packages_explicit="$(pacman -Qeq)"
local _packages_manual="$(pacman -Qmq)"
local _packages_repo="$(Set_Op_Difference "${_packages_explicit}" "${_packages_manual}")"
local _packages_noaur="$(Set_Op_Difference "${_packages_explicit}" "${_packages_manual}")"

PACKAGES_LIVE="$(Set_Op_Difference "${_packages_repo}" "${_packages_groups}")"
AUR_LIVE="$(Set_Op_Intersection "${_packages_explicit}" "${_packages_manual}")"
PACKAGES_MISSING_IN_LIVE="$(Set_Op_Difference "${PACKAGES_FILE}" "${PACKAGES_LIVE}")"
PACKAGES_MISSING_IN_FILE="$(Set_Op_Difference "${PACKAGES_LIVE}" "${PACKAGES_FILE}")"
AUR_MISSING_IN_LIVE="$(Set_Op_Difference "${AUR_FILE}" "${AUR_LIVE}")"
AUR_MISSING_IN_FILE="$(Set_Op_Difference "${AUR_LIVE}" "${AUR_FILE}")"

_report_packages_live="\nOFFICIAL PACKAGES (EXCL. DEPENDENCIES, NO GROUP PACKAGES): \n$(echo ${PACKAGES_LIVE:-NONE})"
_report_aur_live="\nAUR PACKAGES (EXCL. DEPENDENCIES):\n$(echo ${AUR_LIVE:-NONE})"
Unit_Report "$(echo ${_report_packages_live})"
Unit_Report "$(echo ${_report_aur_live})"

case $MODE in
REPORT) # Unit_Report all
    [[ -z ${PACKAGES_MISSING_IN_LIVE:-} ]] \
    || _report_packages_missingin_live="\nSNAPSHOT OFFICIAL PACKAGES NOT INSTALLED ON LIVE SYSTEM: \n$(echo ${PACKAGES_MISSING_IN_LIVE})"
    [[ -z ${AUR_MISSING_IN_LIVE:-} ]] \
    || _report_aur_missingin_live="\nSNAPSHOT AUR PACKAGES NOT INSTALLED ON LIVE SYSTEM: \n${AUR_MISSING_IN_LIVE})"
    [[ -z ${PACKAGES_MISSING_IN_FILE:-} ]] \
    || _report_packages_missinging_file="\nOFFICIAL PACKAGES INSTALLED ON LIVE SYSTEM BUT NOT IN SNAPSHOT: \n$(echo ${PACKAGES_MISSING_IN_FILE})"
    [[ -z ${AUR_MISSING_IN_FILE:-} ]] \
    || _report_aur_missingin_file="\nAUR PACKAGES INSTALLED ON LIVE SYSTEM BUT NOT IN SNAPSHOT: \n$(echo ${AUR_MISSING_IN_FILE})"
    ;;
SNAPSHOT) # Condition add all, conditional remove all

    Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
    [LIST_VAR_NAME]=''
    [LIST_VALUE]="${PACKAGES_MISSING_IN_FILE}"
    [QUERY_STRING]='${_item} on system but not in snapshot. Add to snapshot?'
    [ACTION_CMD]='PACKAGES_FILE="$(Set_Op_Union "${PACKAGES_FILE}" "${_item}")"'
    [EXECUTED_CMD]='UI_Passive_Alert "Added"'
    [SKIPPED_CMD]='UI_Passive_Alert "Skipped"'
    [FAILED_CMD]='UI_Passive_Alert "Failed"'
    [EXECUTED_LIST_CMD]='Unit_Report "ADDED TO SNAPSHOT LIST: ${_executed_list}"'
    [SKIPPED_LIST_CMD]='Unit_Report "NOT ADDED TO SNAPSHOT LIST: ${_skipped_list}"'
    [FAILED_LIST_CMD]='Unit_Report "FAILED TO ADD TO SNAPSHOT LIST: ${_failed_list}"'
    [EXECUTED_RTN_NAME]=''
    [SKIPPED_RTN_NAME]=''
    [FAILED_RTN_NAME]=''
    [FORCE_VALUE]='${FORCE}'
    [DEFAULT_CHOICE]='true'
    ); Ask_Auto_Action ASK_AUTO_SOURCE_

    Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
    [LIST_VAR_NAME]=''
    [LIST_VALUE]="${PACKAGES_MISSING_IN_LIVE}"
    [QUERY_STRING]='${_item} in snapshot but not on system. Remove from snapshot?'
    [ACTION_CMD]='PACKAGES_FILE="$(Set_Op_Difference "${PACKAGES_FILE}" "${_item}")"'
    [EXECUTED_CMD]='UI_Passive_Alert "Added"'
    [SKIPPED_CMD]='UI_Passive_Alert "Skipped"'
    [FAILED_CMD]='UI_Passive_Alert "Failed"'
    [EXECUTED_LIST_CMD]='Unit_Report "ADDED TO SNAPSHOT LIST: ${_executed_list}"'
    [SKIPPED_LIST_CMD]='Unit_Report "NOT ADDED TO SNAPSHOT LIST: ${_skipped_list}"'
    [FAILED_LIST_CMD]='Unit_Report "FAILED TO ADD TO SNAPSHOT LIST: ${_failed_list}"'
    [EXECUTED_RTN_NAME]=''
    [SKIPPED_RTN_NAME]=''
    [FAILED_RTN_NAME]=''
    [FORCE_VALUE]='${FORCE}'
    [DEFAULT_CHOICE]='true'
    ); Ask_Auto_Action ASK_AUTO_SOURCE_

    Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
    [LIST_VAR_NAME]=''
    [LIST_VALUE]="${AUR_MISSING_IN_FILE}"
    [QUERY_STRING]='${_item} on system but not in snapshot. Add to snapshot?'
    [ACTION_CMD]='AUR_FILE="$(Set_Op_Union "${AUR_FILE}" "${_item}")"'
    [EXECUTED_CMD]='UI_Passive_Alert "Added"'
    [SKIPPED_CMD]='UI_Passive_Alert "Skipped"'
    [FAILED_CMD]='UI_Passive_Alert "Failed"'
    [EXECUTED_LIST_CMD]='Unit_Report "ADDED TO SNAPSHOT AUR LIST: ${_executed_list}"'
    [SKIPPED_LIST_CMD]='Unit_Report "NOT ADDED TO SNAPSHOT AUR LIST: ${_skipped_list}"'
    [FAILED_LIST_CMD]='Unit_Report "FAILED TO ADD TO SNAPSHOT AUR LIST: ${_failed_list}"'
    [EXECUTED_RTN_NAME]=''
    [SKIPPED_RTN_NAME]=''
    [FAILED_RTN_NAME]=''
    [FORCE_VALUE]='${FORCE}'
    [DEFAULT_CHOICE]='true'
    ); Ask_Auto_Action ASK_AUTO_SOURCE_

    Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
    [LIST_VAR_NAME]=''
    [LIST_VALUE]="${AUR_MISSING_IN_LIVE}"
    [QUERY_STRING]='${_item} in snapshot but not on system. Remove from snapshot?'
    [ACTION_CMD]='AUR_FILE="$(Set_Op_Difference "${AUR_FILE}" "${_item}")"'
    [EXECUTED_CMD]='UI_Passive_Alert "Added"'
    [SKIPPED_CMD]='UI_Passive_Alert "Skipped"'
    [FAILED_CMD]='UI_Passive_Alert "Failed"'
    [EXECUTED_LIST_CMD]='Unit_Report "ADDED TO SNAPSHOT AUR LIST: ${_executed_list}"'
    [SKIPPED_LIST_CMD]='Unit_Report "NOT ADDED TO SNAPSHOT AUR LIST: ${_skipped_list}"'
    [FAILED_LIST_CMD]='Unit_Report "FAILED TO ADD TO SNAPSHOT AUR LIST: ${_failed_list}"'
    [EXECUTED_RTN_NAME]=''
    [SKIPPED_RTN_NAME]=''
    [FAILED_RTN_NAME]=''
    [FORCE_VALUE]='${FORCE}'
    [DEFAULT_CHOICE]='true'
    ); Ask_Auto_Action ASK_AUTO_SOURCE_

    # WRITE TO FILES
    echo ${PACKAGES_FILE} >> $TMPDIR/${PACKAGES_FILENAME}
    echo ${AUR_FILE} >> $TMPDIR/${AUR_FILENAME}
    local _filename
    for _filename in ${PACKAGES_FILENAME} ${AUR_FILENAME}
    do install -CD --backup=${BACKUP_MODE} -S${BACKUP_SUFFIX} "$TMPDIR/$_filename" "$SNAPSHOT_DIRPATH/$_filename"; done

    ;;
SYSTEM)
    Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
    [LIST_VAR_NAME]=''
    [LIST_VALUE]="${PACKAGES_MISSING_IN_FILE}"
    [QUERY_STRING]='${_item} on system but not in snapshot. Uninstall (recursive + removes unneeded)?'
    [ACTION_CMD]='Install_Package "${_item}" && PACKAGES_LIVE="$(Set_Op_Union "${PACKAGES_LIVE}" "${_item}")"'
    [EXECUTED_CMD]='UI_Passive_Alert "Installed"'
    [SKIPPED_CMD]='UI_Passive_Alert "Skipped"'
    [FAILED_CMD]='UI_Passive_Alert "Failed"'
    [EXECUTED_LIST_CMD]='Unit_Report "INSTALLED TO SYSTEM: ${_executed_list}"'
    [SKIPPED_LIST_CMD]='Unit_Report "NOT INSTALLED TO SYSTEM: ${_skipped_list}"'
    [FAILED_LIST_CMD]='Unit_Report "FAILED TO INSTALL TO SYSTEM: ${_failed_list}"'
    [EXECUTED_RTN_NAME]=''
    [SKIPPED_RTN_NAME]=''
    [FAILED_RTN_NAME]=''
    [FORCE_VALUE]='${FORCE}'
    [DEFAULT_CHOICE]='${FULL_FORCE}'
    ); Ask_Auto_Action ASK_AUTO_SOURCE_

    Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
    [LIST_VAR_NAME]=''
    [LIST_VALUE]="${PACKAGES_MISSING_IN_LIVE}"
    [QUERY_STRING]='${_item} in snapshot but not on system. Install?'
    [ACTION_CMD]='Uninstall_Package "${_item}" && PACKAGES_LIVE="$(Set_Op_Difference "${PACKAGES_LIVE}" "${_item}")"'
    [EXECUTED_CMD]='UI_Passive_Alert "Installed"'
    [SKIPPED_CMD]='UI_Passive_Alert "Skipped"'
    [FAILED_CMD]='UI_Passive_Alert "Failed"'
    [EXECUTED_LIST_CMD]='Unit_Report "UNINSTALLED FROM SYSTEM: ${_executed_list}"'
    [SKIPPED_LIST_CMD]='Unit_Report "NOT UNINSTALLED FROM SYSTEM: ${_skipped_list}"'
    [FAILED_LIST_CMD]='Unit_Report "FAILED TO UNINSTALL FROM SYSTEM: ${_failed_list}"'
    [EXECUTED_RTN_NAME]=''
    [SKIPPED_RTN_NAME]=''
    [FAILED_RTN_NAME]=''
    [FORCE_VALUE]='${FORCE}'
    [DEFAULT_CHOICE]='true'
    ); Ask_Auto_Action ASK_AUTO_SOURCE_

    Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
    [LIST_VAR_NAME]=''
    [LIST_VALUE]="${AUR_MISSING_IN_FILE}"
    [QUERY_STRING]='${_item} on system but not in snapshot. Uninstall (recursive + removes unneeded)?'
    [ACTION_CMD]='Uninstall_Package "${_item}" && AUR_LIVE="$(Set_Op_Difference "${AUR_LIVE}" "${_item}")"'
    [EXECUTED_CMD]='UI_Passive_Alert "Installed"'
    [SKIPPED_CMD]='UI_Passive_Alert "Skipped"'
    [FAILED_CMD]='UI_Passive_Alert "Failed"'
    [EXECUTED_LIST_CMD]='Unit_Report "UNINSTALLED FROM SYSTEM: ${_executed_list}"'
    [SKIPPED_LIST_CMD]='Unit_Report "NOT UNINSTALLED FROM SYSTEM: ${_skipped_list}"'
    [FAILED_LIST_CMD]='Unit_Report "FAILED TO UNINSTALL FROM SYSTEM: ${_failed_list}"'
    [EXECUTED_RTN_NAME]=''
    [SKIPPED_RTN_NAME]=''
    [FAILED_RTN_NAME]=''
    [FORCE_VALUE]='${FORCE}'
    [DEFAULT_CHOICE]='${FULL_FORCE}'
    ); Ask_Auto_Action ASK_AUTO_SOURCE_

    Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
    [LIST_VAR_NAME]=''
    [LIST_VALUE]="${AUR_MISSING_IN_LIVE}"
    [QUERY_STRING]='${_item} in snapshot but not on system. Install?'
    [ACTION_CMD]='Install_AUR "${_item}" && AUR_LIVE="$(Set_Op_Union "${AUR_LIVE}" "${_item}")"'
    [EXECUTED_CMD]='UI_Passive_Alert "Installed"'
    [SKIPPED_CMD]='UI_Passive_Alert "Skipped"'
    [FAILED_CMD]='UI_Passive_Alert "Failed"'
    [EXECUTED_LIST_CMD]='Unit_Report "INSTALLED TO SYSTEM: ${_executed_list}"'
    [SKIPPED_LIST_CMD]='Unit_Report "NOT INSTALLED TO SYSTEM: ${_skipped_list}"'
    [FAILED_LIST_CMD]='Unit_Report "FAILED TO INSTALL TO SYSTEM: ${_failed_list}"'
    [EXECUTED_RTN_NAME]=''
    [SKIPPED_RTN_NAME]=''
    [FAILED_RTN_NAME]=''
    [FORCE_VALUE]='${FORCE}'
    [DEFAULT_CHOICE]='true'
    ); Ask_Auto_Action ASK_AUTO_SOURCE_
    ;;
esac

}

UNIT_Overlay ()
{
# OVERLAY FILE CHECK
# ----------------------------------------------------------------------

Read_File_Lines_To_Array "${OVERLAY_FILEPATH}" OVERLAY_FILES_ARRAY

if [[ -z ${OVERLAY_FILES_ARRAY[*]} ]]
then
    Unit_Report "No overlay file list. To save a snapshot of specific system 
    configuration files, make a line by line list of file paths in the following 
    file: ${OVERLAY_FILEPATH}"
    return 0
fi

Unit_Report "OVERLAY FILES (${OVERLAY_FILEPATH})\n"
DEFAULT_ATTRIBS="644 root root" # used only if we have a snapshot file but no system file and no attribs are listed

_line_num=0
while true
do
    # bail if we're past the end of the array
    [[ $_line_num == ${#OVERLAY_FILES_ARRAY[@]} ]] && break

    # create hashed file array for comparison and recreation of new file
    _line="$(Swap_Out_Escaped_Spaces ${OVERLAY_FILES_ARRAY[$_line_num]})"
    local _path="$(Swap_In_Escaped_Spaces $(echo -n $_line | awk '{print $1}'))"
    local _path_hash="$(Hash_Of "${_path}")"

    FILEHASH_[${_path_hash}]="${_path}" # TODO: remove if unnecessary
    FILE_[${_path_hash},PATH,SYSTEM]="${_path}" # unnecessary?
    FILE_[${_path_hash},PATH,OVERLAY]="$OVERLAY_DIRPATH/${_path#/}"
    FILE_[${_path_hash},ATTRIBS,OVERLAY]="$(echo -n $_line | awk '{print $2,$3,$4}' | sed 's/^\s*\(.*\)\s*/\1/')"
    FILE_[${_path_hash},ATTRIBS,SYSTEM]="$(stat -c '%a %U %G' ${_path} 2>/dev/null | sed 's/^\s*\(.*\)\s*/\1/')"

    # FOLLOWING TESTS: ONE OR BOTH FILES MISSING
    if [[ ! -e "${FILE_[$_path_hash,PATH,SYSTEM]}" && ! -e "${FILE_[$_path_hash,PATH,OVERLAY]}" ]]; then Add_To_Array OVERLAY_MISS_BOTH "${_path}"
    elif [[ ! -e "${FILE_[$_path_hash,PATH,SYSTEM]}" && -e "${FILE_[$_path_hash,PATH,OVERLAY]}" ]]; then Add_To_Array OVERLAY_MISS_SYST "${_path}"
    elif [[ -e "${FILE_[$_path_hash,PATH,SYSTEM]}" && ! -e "${FILE_[$_path_hash,PATH,OVERLAY]}" ]]; then Add_To_Array OVERLAY_MISS_OVER "${_path}"

    # FOLLOWING TESTS: BOTH FILES PRESENT
    elif [[ "${FILE_[$_path_hash,ATTRIBS,SYSTEM]}" != "${FILE_[$_path_hash,ATTRIBS,OVERLAY]}" ]] \
    && $(! diff -q "${FILE_[$_path_hash,PATH,SYSTEM]}" "${FILE_[$_path_hash,PATH,OVERLAY]}" &>/dev/null); then Add_To_Array OVERLAY_DIFF_CONT_ATTR "${_path}"
    elif $(! diff -q "${FILE_[$_path_hash,PATH,SYSTEM]}" "${FILE_[$_path_hash,PATH,OVERLAY]}" &>/dev/null); then Add_To_Array OVERLAY_DIFF_CONT "${_path}"
    elif [[ "${FILE_[$_path_hash,ATTRIBS,SYSTEM]}" != "${FILE_[$_path_hash,ATTRIBS,OVERLAY]}" ]]; then Add_To_Array OVERLAY_DIFF_ATTR "${_path}"
    else Add_To_Array OVERLAY_GOOD "${_path}"
    fi

    let "_line_num+=1"
done

    [[ -n ${OVERLAY_GOOD[@]:-} ]] && Unit_Report "MATCHES ON SYSTEM/SNAPSHOT:\n$(Array_To_Report OVERLAY_GOOD)"
    [[ -n ${OVERLAY_MISS_SYST[@]:-} ]] && Unit_Report "MISSING ON SYSTEM (PRESENT IN SNAPSHOT):\n$(Array_To_Report OVERLAY_MISS_SYST)"
    [[ -n ${OVERLAY_MISS_OVER[@]:-} ]] && Unit_Report "MISSING ON SNAPSHOT (PRESENT ON SYSTEM):\n$(Array_To_Report OVERLAY_MISS_OVER)"
    [[ -n ${OVERLAY_MISS_BOTH[@]:-} ]] && Unit_Report "MISSING ON BOTH SYSTEM AND SNAPSHOT:\n$(Array_To_Report OVERLAY_MISS_BOTH)"
    [[ -n ${OVERLAY_DIFF_ATTR[@]:-} ]] && Unit_Report "ATTRIBUTES DIFFER (OR MISSING) ON SYSTEM/SNAPSHOT:\n$(Array_To_Report OVERLAY_DIFF_ATTR)"
    [[ -n ${OVERLAY_DIFF_CONT[@]:-} ]] && Unit_Report "CONTENTS DIFFER ON SYSTEM/SNAPSHOT:\n$(Array_To_Report OVERLAY_DIFF_CONT)"
    [[ -n ${OVERLAY_DIFF_CONT_ATTR[@]:-} ]] && Unit_Report "ATTRIBS/CONTENTS DIFFER ON SYSTEM/SNAPSHOT:\n$(Array_To_Report OVERLAY_DIFF_CONT_ATTR)"
case $MODE in
REPORT)
#    [[ -n ${OVERLAY_GOOD[@]:-} ]] && Unit_Report "MATCHES ON SYSTEM/SNAPSHOT:\n$(Array_To_Report OVERLAY_GOOD)"
#    [[ -n ${OVERLAY_MISS_SYST[@]:-} ]] && Unit_Report "MISSING ON SYSTEM (PRESENT IN SNAPSHOT):\n$(Array_To_Report OVERLAY_MISS_SYST)"
#    [[ -n ${OVERLAY_MISS_OVER[@]:-} ]] && Unit_Report "MISSING ON SNAPSHOT (PRESENT ON SYSTEM):\n$(Array_To_Report OVERLAY_MISS_OVER)"
#    [[ -n ${OVERLAY_MISS_BOTH[@]:-} ]] && Unit_Report "MISSING ON BOTH SYSTEM AND SNAPSHOT:\n$(Array_To_Report OVERLAY_MISS_BOTH)"
#    [[ -n ${OVERLAY_DIFF_ATTR[@]:-} ]] && Unit_Report "ATTRIBUTES DIFFER (OR MISSING) ON SYSTEM/SNAPSHOT:\n$(Array_To_Report OVERLAY_DIFF_ATTR)"
#    [[ -n ${OVERLAY_DIFF_CONT[@]:-} ]] && Unit_Report "CONTENTS DIFFER ON SYSTEM/SNAPSHOT:\n$(Array_To_Report OVERLAY_DIFF_CONT)"
#    [[ -n ${OVERLAY_DIFF_CONT_ATTR[@]:-} ]] && Unit_Report "ATTRIBS/CONTENTS DIFFER ON SYSTEM/SNAPSHOT:\n$(Array_To_Report OVERLAY_DIFF_CONT_ATTR)"
:
;;
SNAPSHOT)

File_Backup () {
    local _path_hash="${1}";
    Debug "$_path_hash :: ${FILE_[${_path_hash},PATH,SYSTEM]:-}"
    install -CD --backup=${BACKUP_MODE} -S${BACKUP_SUFFIX} "${FILE_[${_path_hash},PATH,SYSTEM]}" "${FILE_[${_path_hash},PATH,OVERLAY]}"
}

Update_Attribs () {
    local _path_hash="${1}";
    FILE_[${_path_hash},ATTRIBS,OVERLAY]="${FILE_[${_path_hash},ATTRIBS,SYSTEM]}"
}

    if [[ -n ${OVERLAY_MISS_OVER[*]:-} ]]; then
    UI_Passive_Alert "MISSING FROM $(Upper_Case $SCRIPTNAME): the following files haven't been saved to your overlay directory yet."
    UI_Passive_Alert "Please choose whether to copy each item to your overlay directory:"
    Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
    [LIST_VAR_NAME]='OVERLAY_MISS_OVER'
    [LIST_VALUE]=''
    [QUERY_STRING]='${_item}'
    [ACTION_CMD]='File_Backup "${_hash}"'
    [EXECUTED_CMD]='Update_Attribs "${_hash}"' #; Unit_Report "ADDED TO $(Upper_Case $SCRIPTNAME): ${_item}"'
    [SKIPPED_CMD]='' #Unit_Report "SKIPPED ADDING TO $(Upper_Case $SCRIPTNAME): ${_item}"'
    [FAILED_CMD]='' #Unit_Report "FAILED TO ADD TO $(Upper_Case $SCRIPTNAME): ${_item}"'
    [EXECUTED_LIST_CMD]='! Is_True $FORCE && Unit_Report "ADDED TO OVERLAY:\n${_executed_list}"'
    [SKIPPED_LIST_CMD]='! Is_True $FORCE && Unit_Report "SKIPPED ADD TO OVERLAY:\n${_skipped_list}"'
    [FAILED_LIST_CMD]='! Is_True $FORCE && Unit_Report "FAILED ADD TO OVERLAY:\n${_failed_list}"'
    [EXECUTED_RTN_NAME]=''
    [SKIPPED_RTN_NAME]=''
    [FAILED_RTN_NAME]=''
    [FORCE_VALUE]='${FORCE}'
    [DEFAULT_CHOICE]='true'
    ); Ask_Auto_Action ASK_AUTO_SOURCE_
    fi

    if [[ -n ${OVERLAY_DIFF_ATTR[*]:-} ]]; then
    UI_Passive_Alert "DIFFERENT ATTRIBUTES: The following files have identical content between the system and ${SCRIPTNAME} but attributes differ:"
    UI_Passive_Alert "Please choose whether to update your overlay file attributes for each item that follows:"
    Unset_Array ASK_AUTO_SOURCE_; ASK_AUTO_SOURCE_=(
    [LIST_VAR_NAME]='OVERLAY_DIFF_ATTR'
    [LIST_VALUE]=''
    [QUERY_STRING]='For file ${_item} :\nchange current OVERLAY ATTRIBUTES: ${FILE_[${_hash},ATTRIBS,OVERLAY]}\nto current SYSTEM ATTRIBUTES: ${FILE_[${_hash},ATTRIBS,SYSTEM]}?'
    [ACTION_CMD]='FILE_[${_hash},ATTRIBS,OVERLAY,OLD]=${FILE_[${_hash},ATTRIBS,OVERLAY]}; FILE_[${_hash},ATTRIBS,OVERLAY]=${FILE_[${_hash},ATTRIBS,SYSTEM]}'
    [EXECUTED_CMD]='Is_True $FORCE && Unit_Report "ATTRIBUTES updated from ${FILE_[${_hash},ATTRIBS,OVERLAY,OLD]} to ${FILE_[${_hash},ATTRIBS,OVERLAY]} for ${_item}"'
    [SKIPPED_CMD]='Is_True $FORCE && Unit_Report "ATTRIBUTES not updated for ${_item} (current overlay ${FILE_[${_hash},ATTRIBS,OVERLAY]}, system ${FILE_[${_hash},ATTRIBS,SYSTEM]})"'
    [FAILED_CMD]='Is_True $FORCE && Unit_Report "FAILED TO update attributes from ${FILE_[${_hash},ATTRIBS,OVERLAY,OLD]} to ${FILE_[${_hash},ATTRIBS,OVERLAY]} for ${_item}"'
    [EXECUTED_LIST_CMD]='! Is_True $FORCE && Unit_Report "ATTRIBUTES UPDATED:\n${_executed_list}"'
    [SKIPPED_LIST_CMD]='! Is_True $FORCE && Unit_Report "SKIPPED ATTRIBUTES UPDATED:\n${_skipped_list}"'
    [FAILED_LIST_CMD]='! Is_True $FORCE && Unit_Report "FAILED ATTRIBUTES UPDATED:\n${_failed_list}"'
    [EXECUTED_RTN_NAME]=''
    [SKIPPED_RTN_NAME]=''
    [FAILED_RTN_NAME]=''
    [FORCE_VALUE]='${FORCE}'
    [DEFAULT_CHOICE]='true'
    ); Ask_Auto_Action ASK_AUTO_SOURCE_
    fi

    UI_Passive_Alert "DIFFERENT FILE CONTENTS: The following files differ in content (attributes match) between ${SCRIPTNAME} and the system:"

    UI_Passive_Alert "DIFFERENT FILE CONTENTS: The following files differ in content and attributes between ${SCRIPTNAME} and the system:"

#    process with ask-auto-action
#    ${_overlay_contents_differ}
#    report with unit-report
#    ${_overlay_missingon_system}
#    ${_overlay_missingon_both}
#    ${_overlay_match}
;;
SYSTEM)
File_Restore () {
    local _path=${1};
    install -CD --backup=${BACKUP_MODE} -S${BACKUP_SUFFIX} -g${_group} -o${_owner} -m${_mode} "$OVERLAY_DIRPATH/${_path#/}" "$_path";
}
;;
esac

}
#    for snapshot update
#    iterate through lists, create new output list/file
#    only write ouput file on total completion (write to tmp and then to final)
#    install any that are different
#    update perms?
#    note about missing_system
#    note about missing_both
#
#    for system
#    iterate through lists, install new file to system for differ/missing_system
#    note about missing_snapshot
#    note about missing_both
#
    # TODO: add a dateline and summary comment at top of each generated file

    # either overlays match or they don't
    # report: report if they match or not
    # update snapshot: copy over
    # update system: copy over
    #
    # make one or several lists (current, different, missing)
    # and ask-auto-action through them



#    ASK_AUTO_SOURCE_=(
#    [LIST_VAR_NAME]=''
#    [LIST_VALUE]="${OVERLAY_FILE}"
#    [QUERY_TEST]=''
#    [QUERY_STRING]='${_item} on system but not in snapshot. Uninstall (recursive + removes unneeded)?'
#    [ACTION_CMD]='Uninstall_Package "${_item}" && AUR_LIVE="$(Set_Op_Difference "${AUR_LIVE}" "${_item}")"'
#    [EXECUTED_CMD]='UI_Passive_Alert "Installed"'
#    [SKIPPED_CMD]='UI_Passive_Alert "Skipped"'
#    [FAILED_CMD]='UI_Passive_Alert "Failed"'
#    [EXECUTED_LIST_CMD]='Unit_Report "UNINSTALLED FROM SYSTEM: ${_executed_list}"'
#    [SKIPPED_LIST_CMD]='Unit_Report "NOT UNINSTALLED FROM SYSTEM: ${_skipped_list}"'
#    [FAILED_LIST_CMD]='Unit_Report "FAILED TO UNINSTALL FROM SYSTEM: ${_failed_list}"'
#    [EXECUTED_RTN_NAME]=''
#    [SKIPPED_RTN_NAME]=''
#    [FAILED_RTN_NAME]=''
#    [FORCE_VALUE]='${FORCE}'
#    [DEFAULT_CHOICE]='false'
#    )
#    #Ask_Auto_Action ASK_AUTO_SOURCE_
#
#
#
#
#










#
#    local _line
#    for _line in ${OVERLAY_FILE}
#    do
#
#        # Read overlay and system file state
#        local _system_file_path=$(echo -n $_line | awk '{print $1}')
#        local _overlaydir_file_path="${OVERLAY_DIRPATH}${_system_file_path}"
#        local _attribs_file=$(echo -n $_line | awk '{print $2,$3,$4}')
#        local _mode_file=$(echo -n $_line | awk '{print $2}')
#        local _owner_file=$(echo -n $_line | awk '{print $3}')
#        local _group_file=$(echo -n $_line | awk '{print $4}')
#        local _attribs_live=$(stat -c '%a %U %G' ${_system_file_path} 2>/dev/null)
#        local _mode_live=$(stat -c '%a' ${_system_file_path} 2>/dev/null)
#        local _owner_live=$(stat -c '%U' ${_system_file_path} 2>/dev/null)
#        local _group_live=$(stat -c '%G' ${_system_file_path} 2>/dev/null)
#        [[ ! -e "${_system_file_path}" ]] \
#        && local _system_file_present=false \
#        || local _system_file_present=true
#        [[ ! -e "${_overlaydir_file_path}" ]] \
#        && local _overlay_file_present=false \
#        || local _overlay_file_present=true
#        diff -q "${_overlaydir_file_path}" "${_system_file_path}" &>/dev/null \
#        && local _overlay_diff=false \
#        || local _overlay_diff=true
#
#        local _state="UNKNOWN"
#        if ! Is_True _overlay_diff && [[ "${_attribs_file}" == "${_attribs_live}" ]]
#        then _state="GOOD"
#        elif Is_True _overlay_diff && [[ "${_attribs_file}" != "${_attribs_live}" ]]
#        then _state="ATTR_DIFF"
#        elif [[ "${_attribs_file}" != "${_attribs_live}" ]]
#        then _state="ATTR"
#        elif Is_True _overlay_diff
#        then _state="DIFF"
#        elif [[ ! -e "${_system_file_path}" && ! -e ${$_overlaydir_file_path} ]]
#        then _state="NO_ALL"
#        elif [[ -e "${_system_file_path}" && ! -e ${$_overlaydir_file_path} ]]
#        then _state="NO_OVR"
#        elif [[ ! -e "${_system_file_path}" && -e ${$_overlaydir_file_path} ]]
#        then _state="NO_SYS"
#        fi
#
#        eval local _id=\"\${OVERLAY_ACTION_${_state}_[ID]:-}\"
#        eval local _report=\"\${OVERLAY_ACTION_${_state}_[REPORT]:-}\"
#        eval local _system_update_query=\"\${OVERLAY_ACTION_${_state}_[SYSTEM_UPDATE_QUERY]:-}\"
#        eval local _system_update_command=\"\${OVERLAY_ACTION_${_state}_[SYSTEM_UPDATE_COMMAND]:-}\"
#        eval local _snapshot_update_query=\"\${OVERLAY_ACTION_${_state}_[SNAPSHOT_UPDATE_QUERY]:-}\"
#        eval local _snapshot_update_command=\"\${OVERLAY_ACTION_${_state}_[SNAPSHOT_UPDATE_COMMAND]:-}\"
#
#        _system_update_command="sudo install -CD --backup=${BACKUP_MODE} -S${BACKUP_SUFFIX} -g${_group_file} -o${_owner_file} -m${_mode_file} ${_overlaydir_file_path} $_system_file_path"
#        _snapshot_update_command="install -CD --backup=${BACKUP_MODE} -S${BACKUP_SUFFIX} $_system_file_path ${_overlaydir_file_path}"
#
        # TODO: Update the actual list along with the install!!!
        # Ack ack ack... this is all wrong. In the case of attribs for 
        # snapshot, I *just* need to change the file, not install (though for 
        # both attribs and content I need to do both)
        #
        # There is wayyyy too much duplication here. Should probably just
        # be setting a couple values through the test and then executing on 
        # them. this would allow the file to be created again line by line (or 
        # rather a list that can then be sorted and written)
        #
        # also the system and snapshot update could almost be abstracted to 
        # a single test if we set a variable up front and eval later
        #
        # Also, the decision/action arrays above could be used during the 
        # package check sequence as well. revisit these and see if they can be 
        # formatted better and generally improved.

#        local _alert= 
#        local _state_line="${_id}: ${_system_file_path} ${_report:+>>> }${_report}"
#        local _state_newline="\n${_state_line}"
#        if ! Is_True ${SYSTEM_UPDATE:-} && ! Is_True ${SNAPSHOT_UPDATE:-}
#        then # REPORT MODE
#            Unit_Report "${_state_line}"
#        elif Is_True ${SNAPSHOT_UPDATE:-} && [[ -n ${_snapshot_update_command:-} ]]
#        then # SNAPSHOT UPDATE MODE
#Debug
#            UI_Passive_Alert "${_state_newline}"
#            if Is_True ${FORCE:-}
#            then
#Debug
#                eval eval "${_snapshot_update_command}" \
#                    && Unit_Report "${_snapshot_update_query}: DONE" \
#                    || Unit_Report "${_snapshot_update_query}: FAILED"
#            else
#                if [[ -z "${_snapshot_update_query}" ]]
#                then
#                    UI_Passive_Alert "${_state_line}"
#                    Unit_Report "${_state_line}"
#                elif Query "${_snapshot_update_query}"
#                then
#Debug
#                    eval eval "${_snapshot_update_command}" \
#                    && _alert="${_snapshot_update_query}: DONE" \
#                    || _alert="${_snapshot_update_query}: FAILED"
#                    UI_Passive_Alert "${_alert}"
#                    Unit_Report "${_state_line} -> ${_alert}"
#                else
#                    #_alert="${_snapshot_update_query:-}: SKIPPED"
#                    _alert="SKIPPED"
#                    UI_Passive_Alert "${_alert}"
#                    Unit_Report "${_state_line} -> ${_alert}"
#                fi
#            fi
#        elif Is_True ${SYSTEM_UPDATE:-} && [[ -n ${_system_update_command:-} ]]
#        then # SYSTEM UPDATE MODE
#Debug
#            UI_Passive_Alert "${_state_newline}"
#            if Is_True ${FORCE:-}
#            then
#Debug
#                eval eval "${_system_update_command}" \
#                    && UI_Passive_Alert "${_system_update_query}: DONE" \
#                    || UI_Passive_Alert "${_system_update_query}: FAILED"
#            else
#                if [[ -z "${_system_update_query}" ]]
#                then
#                    UI_Passive_Alert "${_state_line}"
#                    Unit_Report "${_state_line}"
#                elif Query "${_system_update_query}"
#                then
#Debug
#                    eval eval "${_system_update_command}" \
#                    && _alert="${_system_update_query}: DONE" \
#                    || _alert="${_system_update_query}: FAILED"
#                    UI_Passive_Alert "${_alert}"
#                    Unit_Report "${_state_line} -> ${_alert}"
#                else
#                    #_alert="${_system_update_query}: SKIPPED"
#                    _alert="SKIPPED"
#                    UI_Passive_Alert "${_alert}"
#                    Unit_Report "${_state_line} -> ${_alert}"
#                fi
#            fi
#        else
#Debug
#            UI_Passive_Alert "${_state_line}"
#            Unit_Report "${_state_line}"
#        fi
#    done
#fi


#In system update mode

#In snapshot update mode

#
#    local _line
#    for _line in ${OVERLAY_FILE}
#    do
#        local _path=$(echo -n $_line | awk '{print $1}')
#        local _attribs_file=$(echo -n $_line | awk '{print $2,$3,$4}')
#        if [[ -e "${OVERLAY_[DIRPATH]}${_path}" ]]
#        then
#            local _overlay_file_present=true
#            if [[ -e "${_path}" ]]
#            then
#                # system file present
#                if diff -q "${OVERLAY_[DIRPATH]}${_path}" "${_path}" &>/dev/null
#                then
#                    # files are identical
#                    _message+="\nCONTENT MATCH: Snapshot and system file content are the same for overlay file: ${_path}"
#                else
#                    # files are different
#                    _message+="\nCONTENT DIFF: Snapshot and system file content differ from overlay file: ${_path}"
#                    if Is_True ${OVERLAY_DIFF_DISPLAY}
#                    then
#                        _message+="$(diff -y "${OVERLAY_[DIRPATH]}${_path}" "${_path}" || true)\n"
#                    fi
#                    :
#                fi
#                local _attribs_live=$(stat -c '%a %U %G' ${_path})
#                if [[ "${_attribs_file}" == "${_attribs_live}" ]]
#                then
#                    _message+="\nATTRIB MATCH: Overlay file present and attributes match snapshot: ${_path} ${_attribs_file}"
#                else
#                    _message+="\nATTRIB DIFF: Overlay file present with different attributes: ${_path} SNAPSHOT: ${_attribs_file} SYSTEM: ${_attribs_live}"
#                fi
#            else
#                _message+="\nOverlay file not present on system: ${_path}"
#            fi
#        else
#                _message+="\nOverlay file not present in overlay directory: ${_path}"
#                if [[ -e "${_path}" ]]
#                then
#                    _message+="\nOverlay file present in system: ${_path}"
#                else
#                    _message+="\nOverlay file not present in system: ${_path}"
#                fi
#        fi
#        _message+="\n"
#    done
#    UI_Passive_Alert "${_message}"
#    IFS=$_IFS
#else
#    UI_Passive_Alert "Skipping overlay files check; no overlay file list in 
#    ${OVERLAY_FILEPATH}"
#fi

#_IFS=$IFS; IFS=$'\n'
#for line in ${OVERLAY_FILE}
#do
#    _path=$(echo -n $line | awk '{print $1}')
#    _attribs=$(echo -n $line | awk '{print $2,$3,$4}')
#    [[ -e "${_path}" ]] && _live_attribs=$(stat -c '%a %U %G' ${_path})
#    [[ -z "${_attribs}" && -e "${_path}" ]] && _attribs="${_live_attribs}"
#    OVERLAY_[REVIEWED]+="$_path $_attribs\n"
#    [[ -e "$_path" ]] \
#        && OVERLAY_LIVE+="$_path $_live_attribs\n" \
#        || OVERLAY_LIVE+="$_path $_attribs\n"
#    overlay_files[paths]+="$_path\n"
#done
#IFS=$_IFS

#overlay_files[file]="$(echo -e "${overlay_files[reviewed]}" | sed '/^$/d')"
#overlay_files[live]="$(echo -e "${overlay_files[live]}" | sed '/^$/d')"
#overlay_files[paths]="$(echo -e "${overlay_files[paths]}" | sed '/^$/d')"
#overlay_files[diff]="$(compare "${overlay_files[live]}" "${overlay_files[file]}")"
#report overlay "Overlay file list:"
#report overlay "${overlay_files[file]}"
#if [[ -n ${overlay_files[diff]} ]]
#then
#    report overlay "\nOverlay file items that differ from the live system"
#    report overlay "${overlay_files[diff]}"
#fi
#
#}

UNIT_Report ()
{
# trap was previously ReportResults plus CleanUpEnvironment; if we're 
# here and have a critical failure then we must of course reassign our 
# trap to CleanUpEnvironment (which would have been called after 
# ReportResults)
trap 'UNIT_Clean_Up' INT TERM EXIT
if [[ -n ${REPORT_SEQUENCE_[@]:-} ]]
then
    for _report_category in "${REPORT_SEQUENCE_[@]:-}"
    do
        if [[ -n ${REPORT_[${_report_category}]} ]]
        then
            UI_Passive_Alert "\n$(Upper_Case $_report_category | tr "_" " "):"
            UI_Passive_Alert "--------------------------------------------------------------------------------"
            UI_Passive_Alert "${REPORT_[${_report_category}]}"
        fi
    done
fi

#each sequence unit should be creating a report in a standard format
#and adding to a global report sequence variable
}

UNIT_Clean_Up ()
{
trap - INT TERM EXIT
#remove temp dir
for cleanup_item in "${CLEANUP[@]}"; do eval "$cleanup_item"; done
}

#Safe_Execute ${UNIT_SEQUENCE}
for unit in $UNIT_SEQUENCE
do
    eval UNIT_$unit
done
unset unit
